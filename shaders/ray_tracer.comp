#version 450
#extension GL_EXT_nonuniform_qualifier : require

// Based on the great tutorial "Ray Tracing in One Weekend Series"
//  by Peter Shirley, Trevor David Black, Steve Hollasch
//  https://raytracing.github.io/books/RayTracingInOneWeekend.html

// Noise functions taken from Ray Tracer Demo godot project by HK-SAO
// https://godotengine.org/asset-library/asset/1550

/*

List of features:
    - Supported objects:
        3D simples:
            - TODO 3: Add rounding for 3d simples
            - spheres

        2D simples:
            - triangles

        - planes
        - meshes (Collection of primitives)

    - instancing of objects (spheres so far)

    - Material types:
        -diffuse
        -metallic
        -transparent/glass

    - Multisampling

    - Procedural and sampled textures

    - Refraction tracking (Found out this is called "Nested Dielectrics")


POLICIES
========

The camera points in the negative z direction with positive y being up and positive x being right.

The render image's origin is in the top left. u direction is right and v is down.

Index 0 usually points to an empty or intentionally invalid value.

RayHit structs don't determine normals and intersection points on-hit. They
have to have determine_rayhit called on them afterwards to have valid values.

Normals always point outwards from surfaces and are always normalized on creation.

Ray depth starts at 0 and goes up as depth increases.

Materials have something called refraction_depth. A lower number takes priority.
See Refraction Tracking in PRE PROCESSOR STUFF

mtl_index and object_index refer to a material and an object in the global material list and
object list respectively. There are multiple object lists object_index can point to, which
the object_type enum will determine. The object_type and object_index is
encoded in an object_id. object_id is an unique identifier for every object.

texture_index and texture_type, similarly to object_index and object_type, point to a texture
and specifies what kind of texture it is respectively. Similarly to object_index and object_type,
texture_index and texture_type is consolidated into a texture_id. texture_type can have the flag
is_sampled which means the texture is sampled. If not then the texture is procedurally generated.

Procedural textures are single function files which takes in a vec3 position and returns a vec4 color.
These functions are written in a seperate file and inserted into this file by the preprocessor.
The function's name should be "procedural_texture".

Meshes that are instantiated will have a "mesh-socket" BVHNode as its parent in the global BVH tree.
This node is identifiable by having only one child node and having its transform index be positive.
The transform index should apply to all nodes and objects under the mesh-socket.


LONG TERM GOALS
===============

    - Add detail when standing still -- DONE --

    - Add skybox

    - Add surface textures -- ALMOST --

    - Make set theory functions possible with objects like add and subtract
        (can see insides of objects)

    - Subfurface scattering

    - Add lighting -- BASIC --

    - Make a real time ray tracer with triangle geometry (will be scuffed) -- ALMOST --

    - Implement meshlets for more dynamic materials and better culling (for traingles)

    - Simulate glass of beer

*/


// Invocations in the (x, y, z) dimension
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// PRE PROCESSOR STUFF

/*
Different methods to avoid self intersection
    - method 0: Proposed in Ray Tracing Gems.
        Use a custom function to offset intersection point when creating a new ray.
        My implementation doesn't seem to work correctly as it produces some nasty artifacts.
        Some of them are:
         -visible lines in noise when multisampling is disabled
         -weird lines on a center circle in the random scene
         -being a little more expensive to run
         -darker colors, although that might be more correct
    - method 1: Proposed in Ray tracing in a weekend.
        Simply sets range for valid t values a little above zero.
        TODO 2: Preferred method until I get method 0 to work properly
*/
#define self_intersect_method 1

#if self_intersect_method == 1
#define NEW_RAY_START 0.0001
#elif self_intersect_method == 0
#define NEW_RAY_START 0.0
#endif

/*
// Fun fact, I made it the fuck up
Refraction tracking is the practice of answering the question,
if I enter 3 transparant objects, when I leave only one, what material am I in.
Refraction tracking solves this by assigning a refraction depth value to all materials,
and choosing the material with the lowest depth when leaving an object inside of another/others.

This should, in theory, come with the abiltiy to cut objects with another object that has
air as its material. It also allows for composite glass objects; Rays will travel through multiple
transparent objects with the same material as if it was one homogenous mass,
although at a higher ray depth cost (It might not get out if max_default_depth is low).

Enabling refraction tracking has a small performance impact
*/
#define use_refraction_tracking 1

// TODO 0: Make ray paths that dont find emissive objects return black
// Emissive materials
#define USE_EMISSION 0

// Slower on primary rays but faster on secondary
#define use_early_t_break 0


// TODO 3: Add option to give max ray length for first rays and secondary rays for performance

// CONSTANTS
// =========
const int int_limit = 2147483647;
const int uint_limit = 4294967295;
const int neg_int_limit = -2147483648;
const int all_ones = -1;
const float infinity = 1. / 0.;
const double pi_d = 3.1415926535897932385;
const float pi = 3.1415926535897932385;
const float pi_half = pi / 2.;
const float pi_double = pi * 2;
const float eps = 1e-6;

// Used by offset_ray function
const float origin = 1.0 / 32.0;
const float float_scale = 1.0 / 65536.0;
const float int_scale = 256.0;

// object_type enumerator
// From now on, the object_type is encoded as the first byte of an object_id
const int is_not_obj = 0;
const int is_sphere = 1;
const int is_plane = 2;
const int is_triangle = 3;

// texture_type enumerator
const int is_sampled = 1;
const int is_spatial = 2;

const int is_procedural_flat = 0; // For uv procedural functions
const int is_procedural_spatial = 2; // For point hit procedural function
const int is_sampled_texture = 1; // For uv sampling from texture buffer
const int is_no_texture = 4;

const int MAX_TEXTURE_COUNT = 512;

const int MAX_MESH_COUNT = 64;

// Keeps values of inside_of neatly organized
struct InsideOf {
    int material_index;
    int refraction_depth;
};

// IORs
const float IOR_air = 1.0;
float current_IOR = IOR_air;

// The program will keep track of which objects a ray has passed through to do correct calculations
//  i.e. refraction tracking
// This is the maximum amount of overlapping geomtry that will be considered
const int max_refraction_depth = 8;

// Keeps track of first vacant index in stack
int inside_of_count = 0;

InsideOf empty_inside() {
    return InsideOf(0, int_limit - 1);
}

// Holds the object_id, obejct_type and refraction_depth of and object
InsideOf inside_of[max_refraction_depth] = InsideOf[](
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside()
);
// TODO 3: Add support for cpu to send InsideOf buffer based on camera position

#if !USE_EMISSION
const vec4 default_color = vec4(0.7, 0.7, 0.9, 1);
#endif

#if USE_EMISSION
const vec4 default_color = vec4(0);
bool is_emissive = false;
#endif

const int max_depth = 64 * 16; // Length of rayhits to visit stack in BVH
int refraction_bounces = 0; // Counts the number of times a ray has refracted
int node_hit_count = 0;
int object_hit_count = 0;

// Maximum number of inner nodes a BVHNode can have
const int order = 2; // Replaced by script preprocessor, do NOT touch this line

int current_transform_index = -1;

// Flags
const int flag_size = 31;
const int starting_bit = int(pow(2, flag_size - 1));
bool flags[flag_size];

bool use_bvh;
bool show_bvh_depth;
bool show_node_count;
bool show_object_count;
bool show_normal_view;

bool multisample;

vec4 debug_color = vec4(0);

// Random
// Code snippets taken from Ray tracer demo by HK-SHAO
struct Random {
    float seed;
    float value;
};

Random random = Random(42, 0);

// DATATYPES
// =========
struct Camera {
    vec3 pos;
    float focal_length;
    vec3 right;
    float viewport_width;
    vec3 up;
    float viewport_height;
    vec3 forward;
    float gamma;
};

struct Ray {
    vec3 origin;
    float start;
    vec3 direction;
    float end;
};

struct Material {
    // How much of the light between zero and one is reflected for each color,
    // zero being black
    vec3 albedo;
    // How much the reflections scatter
    float roughness;
    // IDK what this means, metal n stuff, 1 is metal, 0 is dielectric
    float metallic;

    // Value between 0 and 1 where 0 is fully opaque and 1 is fully transparent.
    // Values inbetween determine the energy loss per unit length.
    // Non-opaque materials can refract.
    float opacity;
    float reflectivity;
    // Index of refraction
    float IOR;
    // In cases where a translusent object intersects other objects or contains other translusent
    //  objects, the refraction_depth will determine which object's material will take precedence
    //  in the intersection
    int refraction_depth;
    bool is_emissive;
    int temp2;
    int temp3;
    int temp4;
    int temp11;
    int temp21;
    int temp31;
};

// TODO 1: Move properties to its own array and make global indices that point to object_ids

// The materials stored in objects are indices to a global material array
struct Plane {
    vec3 normal;
    float d;
    int mtl_index;
    uint texture_id;
    int filler0;
    int filler1;
};

struct Sphere {
    vec3 center;
    float radius;
    int mtl_index;
    uint texture_id;
    int filler0;
    int filler1;
};

struct Triangle {
    // TODO 3: SO MUCH SPACE OPTIMIZATION
    vec3 point1;
    float filler1;
    vec3 point2;
    float filler2;
    vec3 point3;
    float filler3;
    vec3 normal;
    float filler4;

    int mtl_index;
    uint texture_id;
    int filler0;
    int filler5;
};

struct RayHit {
    // Stored on-hit
    bool hit;
    int object_id;
    int transform_index;

    // Retrieved later
    vec2 uv;
    vec3 point;
    int mtl_index;
    vec3 normal;
    uint texture_id;
    vec4 color;
};

struct AABB {
    // only xyz is used, they are vec4 to fit memory allocation
    // minimum.x < maximum.x etc. should always be true.
    // The w value is unused by the aabb, so it can be filled with whatever is useful
    vec4 minimum;
    vec4 maximum;
};

struct Transform {
    mat4 matrix;
};

// node_index and size are hidden inside the aabb struct
#define NODE_node_id floatBitsToInt(node.bbox.minimum.w)
#define NODE_node_transform floatBitsToInt(node.bbox.maximum.w)
struct BVHNode {
    // NOTE: Remember that AABB stores FLOATS, not ints
    AABB bbox;
};


// BUFFERS
// =======
layout(rgba32f, set = 0, binding = 0) uniform restrict image2D output_image;

// SET 1 was deprecated.

// Materials
layout(set = 2, binding = 0, std430) restrict readonly buffer MaterialBuffer {
    Material data[];
} materials;

// Objects
layout(set = 2, binding = 1, std430) restrict readonly buffer SpheresBuffer {
    Sphere data[];
} spheres;

layout(set = 2, binding = 2, std430) restrict readonly buffer PlanesBuffer {
    Plane data[];
} planes;

layout(set = 2, binding = 3, std430) restrict readonly buffer TrainglesBuffer {
    Triangle data[];
} triangles;

layout(set = 3, binding = 0, std430) restrict readonly buffer BVH_List {
    BVHNode list[];
} BVH;

layout(set = 3, binding = 1, std430) restrict readonly buffer Object_ID {
    int list[];
} object_ids;

// TODO 2: Make material_index buffer similar to object id

layout(set = 4, binding = 0, std430) restrict readonly buffer TriangleVertex {
    float data[];
} triangle_vertices;

layout(set = 4, binding = 1, std430) restrict readonly buffer TriangleUV {
    float data[];
} triangle_uvs;

layout(set = 4, binding = 2, std430) restrict readonly buffer TriangleIndex {
    float data[];
} triangle_indices;

layout(set = 5, binding = 0) uniform sampler2D Textures[MAX_TEXTURE_COUNT];

layout(set = 6, binding = 0, std430) restrict readonly buffer Transforms {
    Transform data[];
} transforms;

layout(push_constant, std430) restrict readonly uniform constants {
    Camera camera;
    int flags;
    int image_offset_x; // How many pixels offset should the viewport origin be
    int image_offset_y;
    int node_count_threshold;
    int object_count_threshold;
    int width;
    int height;
    int max_default_depth;
    int max_refraction_bounces;
    float time;
    float frame;
    float max_samples;
} push;

// UTILITY FUNCTIONS
// =================

RayHit empty_rayhit() {
    return RayHit(false, 0, -1, vec2(0), vec3(0), 0, vec3(0), 0, vec4(0));
}

float atan2(float y, float x) {
    // Apparantly more stable atan function, read:
    // https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle

    bool s = (abs(x) > abs(y));
    return mix(pi / 2.0 - atan(x,y), atan(y,x), s); // Should perform as well as ternary
}

float reflectance(float eta, float cos_theta) {
    // Schlick's approximation for reflectivety
    float r0 = (1. - eta) / (1. + eta);
    r0 = r0 * r0;
    return r0 + (1. - r0) * pow(1. - cos_theta, 5.);
}

// Random functions
float rand(float seed) {
    return fract((seed * 23489.52364) / 0.0836);
}

float noise(inout Random r) {
    // Also taken from Ray Tracer Demo by HK-SHAO
    r.value = fract(sin(r.seed++) * 43758.5453123);
    return r.value;
}

// Taken from https://www.shadertoy.com/view/XlGcRh by Mark Jarzynski and Marc Olano.
// Which in turn is taken from https://www.pcg-random.org/
float pcg(inout Random r) {
	uint state = (floatBitsToUint(r.seed++)) * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    r.value = ((word >> 22u) ^ word) / 4294967295.0;
	return r.value;
}

float rand2(vec2 co) {
  return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

vec3 random_point_on_sphere() {
    // Consistently faster than other methods by a few dozen microseconds in testing:
    //  -35ms +-15ms / 300 frames
    float theta1 = pcg(random) * pi_double;
    float theta2 = acos(2 * pcg(random) - 1);
    vec3 point = vec3(cos(theta1) * sin(theta2), cos(theta2), sin(theta1) * sin(theta2));

    return point;

}

float hash(vec3 x) {
    // Also taken from Ray Tracer Demo by HK-SHAO
    uvec3 p = floatBitsToUint(x);
    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));
    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));
    uint n = h32 ^ (h32 >> 16U);
    return float(n) * (1.0 / float(0x7fffffff));
}

void swap(inout float a, inout float b) {
    // Swap the values of two floats
    a = a + b;
    b = a - b;
    a = a - b;
}

bool is_close(float value1, float value2) {
    // TODO 2: COnsider implementing this algorithm:
    // https://stackoverflow.com/questions/4915462/how-should-i-do-floating-point-comparison
    // Whether a value is within an epsilon of value2
    return (value2 + eps > value1 && value1 > value2 - eps);
}

bool near_zero(vec3 vec) {
    // Whether a vec3 is close to zero in all fields
    return (abs(vec.x) < eps && abs(vec.y) < eps && abs(vec.z) < eps);
}

bool near_zero(float f) {
    return (abs(f) < eps);
}

vec3 offset_ray(const vec3 point, const vec3 normal) {
    // Calculates a new point for ray intersection, which stops self intersection
    // Implementation of algorithm in Ray Tracing Gems chapter 6.2.2.4
    ivec3 offset = ivec3(normal * int_scale);
    vec3 point_offset = vec3(
        intBitsToFloat(floatBitsToInt(point.x) + ((point.x < 0.) ? -offset.x : offset.x)),
        intBitsToFloat(floatBitsToInt(point.y) + ((point.y < 0.) ? -offset.y : offset.y)),
        intBitsToFloat(floatBitsToInt(point.z) + ((point.z < 0.) ? -offset.z : offset.z))
    );
    return vec3(
        abs(point.x) < origin ? point.x + float_scale * normal.x : point_offset.x,
        abs(point.y) < origin ? point.y + float_scale * normal.y : point_offset.y,
        abs(point.z) < origin ? point.z + float_scale * normal.z : point_offset.z
    );
}

bool in_range(float value, Ray ray) {
    // Is value in range inclusively start and stop values
    return (ray.start <= value && ray.end >= value);
}

bool xin_range(float value, Ray ray) {
    // Is value in range exclusively start and stop values
    return (ray.start < value && ray.end > value);
}

vec3 ray_at(Ray ray) {
    return ray.origin + ray.direction * ray.end;
}

vec3 ray_at(Ray ray, float t) {
    return ray.origin + ray.direction * t;
}

void parse_flags() {
    int bit = starting_bit;
    int num = push.flags;
    // Loop over the i-th bit from most significant to least
    for (int i = flag_size - 1; i >= 0; i--) {
        num -= bit;
        if (num < 0) {
            flags[i] = false;
            num += bit;
        } else {
            flags[i] = true;
        }
        bit = bit >> 1;
    }

    use_bvh = flags[0];
    show_bvh_depth = flags[1];
    multisample = flags[2];
    show_node_count = flags[3];
    show_object_count = flags[4];
    show_normal_view = flags[5];
}

int get_object_type(int object_id) {
    return bitfieldExtract(object_id, 24, 8);
}

int get_object_index(int object_id) {
    return bitfieldExtract(object_id, 0, 24);
}

int get_node_index(int node_id) {
    return bitfieldExtract(node_id, 0, 24);
}

int get_node_size(int node_id) {
    return abs(bitfieldExtract(node_id, 24, 8));
}

uint get_texture_type(uint texture_id) {
    return bitfieldExtract(texture_id, 30, 2);
}

uint get_texture_index(uint texture_id) {
    return bitfieldExtract(texture_id, 0, 30);
}


// TEXTURE STUFF
// =============

vec2 sphere_get_uv(vec3 pos) {
    float theta = acos(pos.y);
    float phi = atan(-pos.z, pos.x) + pi;

    vec2 uv = vec2(phi / pi_double, theta / pi);

    return uv;
}

// Preprocessor will place procedural function definitions here
//procedural_texture_function_definition_hook

vec4 procedural_texture(vec3 pos, uint function) {
    // This function will be pre processed and filled procedural texture functions.
    // For sampled textures there is a different implementation (not yet implemented)

    // Return white as default function
    if (function == 0) {
        return vec4(1);
    }

    // Preprocessor will insert procedural texture functions here
    //procedural_texture_function_call_hook

    // Return black when function not found
    return vec4(0);
}


vec4 get_texture(RayHit rayhit) {
    uint texture_type = get_texture_type(rayhit.texture_id);
    uint texture_index = get_texture_index(rayhit.texture_id);
    vec3 sampled_point = (texture_type & is_spatial) > 0 ? rayhit.point : vec3(rayhit.uv, 0);

    if ((texture_type & is_sampled) > 0) {
        return texture(nonuniformEXT(Textures[texture_index]), rayhit.uv);
    }

    return procedural_texture(sampled_point, texture_index);
}


// RAY-HIT FUNCTIONS
// =============

vec4 hit_skybox(Ray ray, inout RayHit rayhit) {
    // TODO 2: Implement skybox texture and hit detection
    return default_color;
}

float hit_AABB(Ray ray, AABB bbox, vec3 inv_dir, bvec3 is_dir_neg) {
    // I think I got this implementation from stackoverflow, but I forgot where from
    node_hit_count++;
    // Returns true if ray hits aabb within given range
    for (int i = 0; i < 3; i++) {
        float t0 = ((bbox.minimum[i] - ray.origin[i]) * inv_dir[i]);
        float t1 = ((bbox.maximum[i] - ray.origin[i]) * inv_dir[i]);

        // Make sure t0 is smallest
        if (is_dir_neg[i]) {swap(t0, t1);}

        if (t0 > ray.start) {ray.start = t0;}
        if (t1 < ray.end) {ray.end = t1;}

        if (ray.end <= ray.start) {return -1.0;}
    }
    // But if ray origin is inside the box shouldn't ray.start be negative?
    return ray.start; // t value of ray intersecting the bounding box
    // return (ray.start > 0.0) ? ray.start : ray.end; // t value of ray intersecting the bounding box
}

RayHit hit_sphere(inout Ray ray, int object_id, inout RayHit rayhit) {

    Sphere sphere = spheres.data[get_object_index(object_id)];
    // Calculate the determinant of quadratic formula
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float discriminant = half_b * half_b - a*c;

    // Early return if ray does not hit
    if (discriminant < 0.) {
        return rayhit;
    }

    float sqrtd = sqrt(discriminant);
    float root = (-half_b - sqrtd) / a;

    // If root is within a valid t range and less than previous rayhit
    if (!in_range(root, ray)) {
        root = (-half_b + sqrtd) / a;
        if (!in_range(root, ray)) {
            return rayhit;
        }
    }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    rayhit.transform_index = current_transform_index;
    ray.end = root;

    return rayhit;
}

RayHit hit_spheres(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope sphere array to bypass function parameter limitations
    for (int i = 0; i < spheres.data.length(); ++i) {
        hit_sphere(ray, i + (is_sphere << 24), rayhit);
    }
    return rayhit;
}

RayHit hit_plane(inout Ray ray, int object_id, inout RayHit rayhit) {

    Plane plane = planes.data[get_object_index(object_id)];

    float intersection_t = ((plane.d - dot(ray.origin, plane.normal)) /
                            dot(plane.normal, ray.direction));

    // Early return if plane is paralell, even if the ray is contained in the plane
    if (isnan(intersection_t) || (isinf(intersection_t))) {
        return rayhit;
    }

    // Early return if t is not in range of ray
    if (!in_range(intersection_t, ray)) {
        return rayhit;
    }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    rayhit.transform_index = current_transform_index; // Not really relevant to planes
    ray.end = intersection_t;

    return rayhit;
}

RayHit hit_planes(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope planes array to bypass function parameter limitations
    for (int i = 0; i < planes.data.length(); ++i) {
        hit_plane(ray, i + (is_plane << 24), rayhit);
    }
    return rayhit;
}


// RAY-TRIANGLE INTERSECTION FUNCTIONS
// ===================================

// TODO 2: Compare branched vs branchless when support for importing meshes
bool hit_triangle_MT_branchless(inout Ray ray, int object_id, inout RayHit rayhit) {
    // Implementation of the Moller-Trumbore algorithm made by BrunoLevy, fitted to project
    // https://stackoverflow.com/a/42752998

    int triangle_index = get_object_index(object_id);

    vec3 A = triangles.data[triangle_index].point1;
    vec3 B = triangles.data[triangle_index].point2;
    vec3 C = triangles.data[triangle_index].point3;

    vec3 E1 = B-A;
    vec3 E2 = C-A;
    vec3 N = cross(E1,E2);
    float det = -dot(ray.direction, N);
    float invdet = 1.0 / det;
    vec3 AO  = ray.origin - A;
    vec3 DAO = cross(AO, ray.direction);
    float u =  dot(E2,DAO) * invdet;
    float v = -dot(E1,DAO) * invdet;
    float t =  dot(AO,N)  * invdet;

    // NOTE: CAN BE OPTIMIZED LATER
    if ((det >= 1e-6 && in_range(t, ray) && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0)) {
        rayhit.hit = true;
        rayhit.object_id = object_id;
        rayhit.transform_index = current_transform_index;
        ray.end = t;
        return true;
    }

    return false;
}

bool hit_triangle_MT(inout Ray ray, int object_id, inout RayHit rayhit) {
    // Implementation of the Moller-Trumbore algorithm made by BrunoLevy, fitted to project
    // https://stackoverflow.com/a/42752998

    int triangle_index = get_object_index(object_id);

    vec3 A = triangles.data[triangle_index].point1;
    vec3 B = triangles.data[triangle_index].point2;
    vec3 C = triangles.data[triangle_index].point3;

    vec3 E1 = B-A;
    vec3 E2 = C-A;
    vec3 N = cross(E1,E2);
    float det = -dot(ray.direction, N);
    // TODO 3: Add global backface cull flag and object flag

    // If ray is parallel to triangle plane
    if (near_zero(det)) {
        return false;
    }

    float invdet = 1.0 / det;
    vec3 AO = ray.origin - A;
    float t = dot(AO,N) * invdet;

    if (!in_range(t, ray)) {
        return false;
    }

    vec3 DAO = cross(AO, ray.direction);
    float u = dot(C - A, DAO) * invdet;
    float v = -dot(B - A, DAO) * invdet;

    if (u >= 0.0 && v >= 0.0 && (u+v) <= 1.0) {
        rayhit.hit = true;
        rayhit.object_id = object_id;
        rayhit.transform_index = current_transform_index;
        ray.end = t;
        return true;
    }

    return false;
}

RayHit hit_triangles(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope planes array to bypass function parameter limitations
    for (int i = 0; i < triangles.data.length(); ++i) {
        hit_triangle_MT(ray, i + (is_triangle << 24), rayhit);
    }
    return rayhit;
}

void hit_object(inout Ray ray, inout RayHit rayhit, int object_id) {
    // Chooses the appropriate hit_ function for given object_type
    int object_type = get_object_type(object_id);
    object_hit_count++;

    if (object_type == is_sphere) {
        hit_sphere(ray, object_id, rayhit);
    } else if (object_type == is_triangle) {
        // TODO 2: compare with branchless
        hit_triangle_MT(ray, object_id, rayhit);
    }
}


// OTHER RAY FUNCTIONS
// ===================

RayHit determine_rayhit(Ray ray_in, inout RayHit rayhit) {
    // Resolves intersextion point, normal and other information from rayhit
    rayhit.point = ray_at(ray_in);

    int object_type = get_object_type(rayhit.object_id);
    int object_index = get_object_index(rayhit.object_id);

    // TODO 2: texture_id should also be an index to data with the following:
    //  vec3 offset
    //  vec3 scale
    //  bool ignore_albedo

    // Procedure for hitting sphere
    if (object_type == is_sphere) {
        Sphere sphere = spheres.data[object_index];
        rayhit.mtl_index = sphere.mtl_index;
        rayhit.texture_id = sphere.texture_id;

        if (rayhit.transform_index >= 0) {
            mat4 matrix = inverse(transforms.data[rayhit.transform_index].matrix);

            Ray transformed_ray = ray_in;
            transformed_ray.direction = (vec4(ray_in.direction, 0) * matrix).xyz;
            transformed_ray.origin = (vec4(ray_in.origin, 1) * matrix).xyz;

            // Normal in object space
            rayhit.normal = (ray_at(transformed_ray) - sphere.center) / sphere.radius;
            // Setting uvs early gives them the rotation of the sphere.
            rayhit.uv = sphere_get_uv(rayhit.normal);

            // Normal in world space
            rayhit.normal = normalize((vec4(rayhit.normal, 0) * inverse(matrix)).xyz);
        } else {
            rayhit.normal = (rayhit.point - sphere.center) / sphere.radius;
            rayhit.uv = sphere_get_uv(rayhit.normal);
        }

    // Procedure for hitting plane
    } else if (object_type == is_plane) {
        Plane plane = planes.data[object_index];
        rayhit.mtl_index = plane.mtl_index;
        rayhit.texture_id = plane.texture_id;
        rayhit.normal = plane.normal;

    // Procedure for hitting triangle
    } else if (object_type == is_triangle) {
        Triangle triangle = triangles.data[object_index];
        rayhit.mtl_index = triangle.mtl_index;
        rayhit.texture_id = triangle.texture_id;

        rayhit.normal = triangle.normal;
        if (rayhit.transform_index >= 0) {
            mat4 matrix = inverse(transforms.data[rayhit.transform_index].matrix);

            rayhit.normal = normalize((matrix * vec4(rayhit.normal, 0)).xyz);
        }
        if (dot(rayhit.normal, ray_in.direction) > 0) {
            rayhit.normal *= -1;
        }
    }


    rayhit.color = vec4(materials.data[rayhit.mtl_index].albedo, 1);
    #if USE_EMISSION
    is_emissive = materials.data[rayhit.mtl_index].is_emissive;
    #endif
    return rayhit;
}

RayHit check_ray_hit(inout Ray ray) {
    RayHit rayhit = empty_rayhit();

    hit_spheres(ray, rayhit);
    hit_triangles(ray, rayhit);
    hit_planes(ray, rayhit);

    return rayhit;
}

// Stack of indices of nodes yet to traverse
// NOTE: might need to be bigger for larger scenes and/or with higher order trees
int to_visit[max_depth];
int to_visit_i;

int temp_children[order];
float temp_ts[order];

#if use_early_t_break
float to_visit_t[max_depth];
#endif

void calculate_top_node(inout Ray ray, inout RayHit rayhit, vec3 inv_dir, bvec3 is_neg) {
        int current_index = to_visit[--to_visit_i];

        BVHNode node = BVH.list[current_index];
        int node_id = NODE_node_id;
        int node_index = get_node_index(node_id);
        int node_size = get_node_size(node_id);

        /* All nodes in to_visit should be in sorted order,
         we can break if the last node is out of range
        NOTE: This is slow for first rays, but seem comparable for secondary rays.
        TODO 3: Make toggle to use this for secondary rays
        */
        #if use_early_t_break
        if (!in_range(to_visit_t[to_visit_i], ray)) {
            break;
        }
        #endif

        // If node is leaf node, hit all children
        // node_index pointing to nodes should never be zero (root_node)
        // node_index should always be negative for bit manip consistency
        if (node_index <= 0) {
            for (int k = 0; k < node_size; k++) {
                hit_object(ray, rayhit, object_ids.list[abs(node_index) + k - 1]);
            }
            return;
        }

        int added_children = 0;
        // Do hit check on child inner nodes and add them to temp array
        for (int l = 0; l < node_size; l++) {
            BVHNode child = BVH.list[node_index + l];

            float aabb_t = hit_AABB(ray, child.bbox, inv_dir, is_neg);

            // xin_range much faster, but has an artifact
            if (in_range(aabb_t, ray)) {
                added_children++;
                temp_ts[l] = aabb_t;
                temp_children[l] = node_index + l;
            }
        }

        // TODO 3: COnsider min heap or insertion sort
        // Add nodes to stack in a sorted order
        to_visit_i += added_children;
        for (int i = 0; i < added_children; i++) { // Looping over constant is not faster here
            // Finds smallest t, closest box
            float smallest_t = infinity;
            int smallest_index = order;
            for (int j = 0; j < order; j++) { // Looping over constant is faster here
                if (temp_ts[j] < smallest_t ) {
                    smallest_t = temp_ts[j];
                    smallest_index = j;
                }
            }

            // Zero out the smallest
            temp_ts[smallest_index] = infinity;
            to_visit[to_visit_i - i - 1] = temp_children[smallest_index];
            #if use_early_t_break
            to_visit_t[to_visit_i - i - 1] = smallest_t;
            #endif
        }
    }

float check_ray_hit_BVH_mesh(Ray ray, inout RayHit rayhit) {

    // Pre-compute values for hit detection
    vec3 inv_direction = vec3(1) / ray.direction;
    bvec3 is_dir_negative = bvec3(inv_direction.x < 0., inv_direction.y < 0., inv_direction.z < 0.);

    // Index to current node being processed
    int current_index;
    int start_index = to_visit_i;

    while (to_visit_i >= start_index && to_visit_i <= max_depth) {
        calculate_top_node(ray, rayhit, inv_direction, is_dir_negative);
    }

    return ray.end;
}

RayHit check_ray_hit_BVH(inout Ray ray) {
    RayHit rayhit = empty_rayhit();

    // NOTE: Objects that go before bvh can be used as Occluders
    hit_planes(ray, rayhit);

    // Pre-compute values for hit detection
    vec3 inv_direction = vec3(1) / ray.direction;
    bvec3 is_dir_negative = bvec3(inv_direction.x < 0., inv_direction.y < 0., inv_direction.z < 0.);

    // TODO 3: Another improvement might be to precompute all rays for every mesh per trace call

    // Test if root node is hit by ray
    float root_hit = hit_AABB(ray, BVH.list[0].bbox, inv_direction, is_dir_negative);

    // Index to top of the stack, points to vacant spot ABOVE the stack
    to_visit_i = (in_range(root_hit, ray)) ? 1 : 0;
    to_visit[0] = 0;

    #if use_early_t_break
    to_visit_t[0] = root_hit;
    #endif

    for (int h = 0; h < order; h++) {
        temp_ts[h] = infinity;
    }

    while (to_visit_i > 0 && to_visit_i <= max_depth) {
        int current_index = to_visit[--to_visit_i];

        BVHNode node = BVH.list[current_index];
        int node_id = NODE_node_id;
        int node_index = get_node_index(node_id);
        int node_size = get_node_size(node_id);

        /* All nodes in to_visit should be in sorted order,
         we can break if the last node is out of range
        NOTE: This is slow for first rays, but seem comparable for secondary rays.
        TODO 3: Make toggle to use this for secondary rays
        */
        #if use_early_t_break
        if (!in_range(to_visit_t[to_visit_i], ray)) {
            break;
        }
        #endif

        int transform_index = NODE_node_transform;
        if (transform_index >= 0) {

            mat4 matrix = transforms.data[transform_index].matrix;

            Ray new_ray = ray;
            new_ray.direction = (matrix * vec4(ray.direction, 0)).xyz;
            new_ray.origin = (matrix * vec4(ray.origin, 1)).xyz;

            #if use_early_t_break
            BVHNode child = BVH.list[node_index];
            float aabb_t = hit_AABB(ray, child.bbox, inv_direction, is_dir_negative);
            to_visit_t[to_visit_i] = aabb_t;
            #endif
            to_visit[to_visit_i++] = node_index;

            current_transform_index = transform_index;
            ray.end = check_ray_hit_BVH_mesh(new_ray, rayhit);
            current_transform_index = -1;

            continue;
        }

        to_visit_i++;
        calculate_top_node(ray, rayhit, inv_direction, is_dir_negative);
    }

    return rayhit;
}

// RAY-BOUNCE FUNCTIONS
// ====================
Ray reflect_ray(Ray ray_in, RayHit rayhit) {
    // Returns a new reflected ray based on ray_in and rayhit

    vec3 new_origin = rayhit.point;

    #if self_intersect_method==0
    new_origin = offset_ray(rayhit.point, rayhit.normal);
    #endif

    float metallic = materials.data[rayhit.mtl_index].metallic;

    vec3 reflected_dir = reflect(ray_in.direction, rayhit.normal) * metallic;
    vec3 dir_offset = random_point_on_sphere() * (1. - metallic);

    vec3 ray_dir = reflected_dir + dir_offset;

    // Reflects ray if it points into the object
    if (dot(ray_dir, rayhit.normal) < 0.) {
        ray_dir = reflect(ray_dir, rayhit.normal);
    }

    return Ray(new_origin, NEW_RAY_START, ray_dir, infinity);
}

// TODO 3: Experiment with max heap instead of array, or insert sorted list
int get_material(int material_index, int lowest_depth, bool ignore_self) {
    // Loop over materials that we have entered and not left,
    //  pick the one with the lowest refraction_depth, ignore default values if specified
    int current_index = material_index;
    for (int i = 0; i < max_refraction_depth; i++) {
        InsideOf index = inside_of[i];
        if (index.refraction_depth < lowest_depth) {
            if (!(material_index == index.material_index) || !ignore_self) {
                lowest_depth = index.refraction_depth;
                current_index = index.material_index;
            } else {
                // same material is true, we ignore the same material one time
                ignore_self = false;
            }
        }
    }

    return current_index;
}

void remove_object_from_inside_of(int material_index) {
    int shift = 0;
    // NOTE: inside_of_count tested to be faster than looping over entire array
    for (int i = 0; i < inside_of_count; i++) {
        InsideOf index = inside_of[i];
        if (material_index == index.material_index) {
            shift = 1;
        }
        inside_of[i] = inside_of[i + shift];
    }
    inside_of_count--;
}

Ray refract_ray(Ray ray_in, inout RayHit rayhit) {
    // Returns a refracted or reflected ray based on ray_in and rayhit
    // TODO 3: Add support for cpu to send InsideOf buffer based on camera position
    // TODO 3: Add tiny random direction change coupled with color shift, prism, diffraction
    // TODO 2: Add support for meshes to refract
    // TODO 2: Implement Beer's law:
    // https://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_3_Refractions_and_Beers_Law.shtml

    vec3 new_origin = rayhit.point;

    // Whether object is inside the current object
    bool is_inside = bool(dot(rayhit.normal, ray_in.direction) > 0.);
    vec3 normal = (is_inside) ? -rayhit.normal : rayhit.normal;

    float eta_in = current_IOR;

    Material material = materials.data[rayhit.mtl_index];

    #if use_refraction_tracking==0
    float eta_out = (is_inside) ? IOR_air : material.IOR;
    float eta = eta_in / eta_out;
    #endif

    #if use_refraction_tracking==1
    // If ray is inside object ignore rayhti.mtl_index as having a possible eta_out, else
    //  rayhit.mtl_index is default material if no other materials are in inside_of.
    int depth = is_inside ? int_limit : material.refraction_depth;
    int current_material = get_material(rayhit.mtl_index, depth, is_inside);

    float eta_out = materials.data[current_material].IOR;
    float eta = eta_in / eta_out;

    // If ratio is one the ray will travel in a straight line
    if (is_close(eta, 1.0)) {
        // If ray was inside and went out, remove from inside_of list
        if (is_inside) {
            remove_object_from_inside_of(rayhit.mtl_index);
        } else {
            // If ray was outside and refracted, add to inside_of list
            inside_of[inside_of_count++] = InsideOf(rayhit.mtl_index, material.refraction_depth);
        }

        #if self_intersect_method==0
        new_origin = offset_ray(new_origin, -normal);
        #endif

        // TODO 3: Only invalidate color if this object has the same color as the previous object
        // Handle this in a more explicit way.
        rayhit.hit = false;

        // Add extra available bounces when ray refracts/goes through another object
        if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

        return Ray(new_origin, NEW_RAY_START, ray_in.direction, infinity);
    }
    #endif

    vec3 normalized_direction = normalize(ray_in.direction);

    // Calculate whether angle is shallow enough to disallow refraction
    float cos_theta = min(dot(-normalized_direction, normal), 1.);
    float sin_theta = sqrt(1. - cos_theta * cos_theta);
    bool cannot_refract = eta * sin_theta > 1.;

    // Check for internal reflection
    if ((reflectance(eta, cos_theta) * (material.reflectivity) > noise(random)) || cannot_refract) {
        #if self_intersect_method==0
        return Ray(offset_ray(new_origin, normal), NEW_RAY_START, reflect(normalized_direction, normal), infinity);
        #endif

        #if self_intersect_method==1
        return Ray(new_origin, NEW_RAY_START, reflect(normalized_direction, normal), infinity);
        #endif
    }

    current_IOR = eta_out;

    #if use_refraction_tracking==1
    // If ray was inside and went out, remove from inside_of list
    if (is_inside) {
        remove_object_from_inside_of(rayhit.mtl_index);
    } else {
        // If ray was outside and refracted, add to inside_of list
        inside_of[inside_of_count++] = InsideOf(rayhit.mtl_index, material.refraction_depth);
    }
    #endif

    #if self_intersect_method==0
    new_origin = offset_ray(new_origin, -normal);
    #endif

    // Add extra available bounces when ray refracts/goes through another object
    if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

    return Ray(new_origin, NEW_RAY_START, refract(normalized_direction, normal, eta), infinity);
}

Ray scatter_ray(Ray ray_in, RayHit rayhit) {
    // TODO 2: Change the way rays are created based on roughness, less/ more scatter

    #if self_intersect_method==0
    vec3 new_origin = offset_ray(rayhit.point, rayhit.normal);
    #endif

    #if self_intersect_method==1
    vec3 new_origin = rayhit.point;
    #endif

    // Returns a scattered ray based on ray_in and rayhit
    vec3 ray_dir = random_point_on_sphere() + rayhit.normal;

    // If created ray pointed in opposite direction of normal
    ray_dir = near_zero(ray_dir) ? rayhit.normal : ray_dir;

    // Make sure reflected ray points in the same way as normal
    ray_dir = dot(ray_dir, rayhit.normal) < 0. ? ray_dir * -1.0 : ray_dir;

    return Ray(new_origin, NEW_RAY_START, ray_dir, infinity);
}

Ray bounce_ray(Ray ray_in, inout RayHit rayhit) {
    // Creates a new ray based material properties from the previous rayhit

    // TODO 2: Make more sophisticated function choosing
    if (materials.data[rayhit.mtl_index].opacity < 1.) {
        return refract_ray(ray_in, rayhit);
    }

    if (materials.data[rayhit.mtl_index].metallic > 0.) {
        return reflect_ray(ray_in, rayhit);
    }

    return scatter_ray(ray_in, rayhit);
}

// MAIN FUNCTIONS
// ==============
vec4 cast_ray(Ray ray) {
    // Casts a ray with bounces and returns the color of the ray

    // Turns out computing colors in the same loop was faster
    // TODO 3: maybe reconsider

    // Calculate rayhits
    Ray new_ray = ray;
    RayHit rayhit;
    refraction_bounces = 0;
    vec4 new_color = vec4(1);
    vec4 tex_col = vec4(1);

    // MICRO-OPT Having the loop be static/const is slightly faster than with having it dynamic
    for (int i = 0; i < push.max_default_depth + refraction_bounces; i++) {
        if (use_bvh) {
            rayhit = check_ray_hit_BVH(new_ray);

            // Send one ray, skip bouncing
            if (show_bvh_depth) {
                float a = show_node_count ? float(node_hit_count) / float(push.node_count_threshold) : 0.0;
                float b = show_object_count ? float(object_hit_count) / float(push.object_count_threshold) : 0.0;
                rayhit.color = (max(a, b) > 1.0) ? vec4(1) : vec4(b, 0, a, 0);
                new_color = rayhit.color;
                break;
            }
        } else {
            rayhit = check_ray_hit(new_ray);
        }

        // TODO 2: Try using continues instead
        // Early break if no hit
        if (!rayhit.hit) {
            // Adds sky color as the last rayhit when miss
            rayhit.color = hit_skybox(ray, rayhit);
            new_color *= rayhit.color;
            break;
        }

        determine_rayhit(new_ray, rayhit);

        if (show_normal_view) {
            return vec4((rayhit.normal + vec3(1)) / 2.0, 1);
        }

        #if USE_EMISSION
        if (is_emissive) {
            new_color *= rayhit.color;
            break;
        } else {is_emissive = false;} // This never does anything
        #endif

        // Get texture color
        tex_col = get_texture(rayhit);

        new_ray = bounce_ray(new_ray, rayhit);

        // TODO 2: implement attenuation based on incident and exiting angles

        // Rayhit is invalidated if the ray goes through two transparent objects with the same material
        if (rayhit.hit) {
            new_color *= rayhit.color * tex_col;
        }
    }

    return new_color;
}


// The code we want to execute in each invocation
void main() {

    // VARIABLE DEFINITIONS
    // ====================

    // Calculate the vectors across the horizontal and down the vertical viewport edges.
    const vec3 viewport_u = push.camera.right * push.camera.viewport_width;
    const vec3 viewport_v = -push.camera.up * push.camera.viewport_height;

    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
    const vec3 pixel_delta_u = viewport_u / push.width;
    const vec3 pixel_delta_v = viewport_v / push.height;

    // Calculate the location of the upper left pixel.
    const vec3 viewport_upper_left = push.camera.pos - push.camera.forward * push.camera.focal_length -
                                     (viewport_u + viewport_v) / 2.;

    const vec3 pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);

    // gl_GlobalInvocationID uniquely identifies this invocation across all work groups
    // const uvec3 UVu = gl_GlobalInvocationID + uvec3(push.image_offset, 0);
    const ivec3 UVi = ivec3(gl_GlobalInvocationID) + ivec3(push.image_offset_x, push.image_offset_y, 0);
    const vec3 UV = vec3(UVi);

    const vec3 pixel_center = pixel00_loc + (UV.x * pixel_delta_u) + (UV.y * pixel_delta_v);

    random.seed = hash(vec3(UV.xy, push.time));

    // Initialize render flags
    parse_flags();

    // CODE
    // ====

    // Create ray with offset
    vec3 offset = (pixel_delta_u / 2) * (rand(float(push.time)) - 1.) +
                  (pixel_delta_v / 2) * (rand(float(push.time)) - 1.);
    vec3 ray_direction = pixel_center - push.camera.pos + offset;
    Ray ray = Ray(push.camera.pos, NEW_RAY_START, ray_direction, infinity);

    // Cast ray
    vec4 new_color = cast_ray(ray);

    // Apply gamma correction
    new_color.rgb = pow(new_color.rgb, vec3(push.camera.gamma));

    // TODO 3: use max_samples to divide
    if (multisample) {
        vec4 prev_col = imageLoad(output_image, UVi.xy);
        new_color = mix(prev_col, new_color, 1.0 / max(1.0, push.frame));
        // new_color = prev_col + new_color / push.max_samples;
        // if (push.frame == 0) {
        //     new_color = vec4(0);
        // }
    }

    if (debug_color != vec4(0)) {
        new_color = debug_color;
    }

    imageStore(output_image, UVi.xy, new_color);
}
