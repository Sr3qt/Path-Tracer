#version 450
#extension GL_EXT_nonuniform_qualifier : require

// Based on the great tutorial "Ray Tracing in One Weekend Series"
//  by Peter Shirley, Trevor David Black, Steve Hollasch 
//  https://raytracing.github.io/books/RayTracingInOneWeekend.html

// Noise functions taken from Ray Tracer Demo godot project by HK-SAO
// https://godotengine.org/asset-library/asset/1550 

/*

List of features:
    - Supported objects:
        3D simples:
            - TODO Add rounding for 3d simples
            - spheres

        2D simples:
            - triangles  

        - planes
        - meshes (Collection of primitives)
    
    - instancing of objects (spheres so far)

    - Material types:
        -diffuse
        -metallic
        -transparent/glass
    
    - Multisampling

    - Procedural and sampled textures

    - Refraction tracking (Found out this is called "Nested Dielectrics")


POLICIES
========

The camera points in the negative z direction with positive y being up and positive x being right.

The render image's origin is in the top left. u direction is right and v is down.

Index 0 usually points to an empty or intentionally invalid value.

RayHit structs don't determine normals and intersection points on-hit. They 
have to have determine_rayhit called on them afterwards to have valid values.

Normals always point outwards from surfaces and are always normalized on creation.

Ray depth starts at 0 and goes up as depth increases.

Materials have something called refraction_depth. A lower number takes priority. 
See Refraction Tracking in PRE PROCESSOR STUFF

mtl_index and object_index refer to a material and an object in the global material list and 
object list respectively. There are multiple object lists object_index can point to, which 
the object_type enum will determine. The object_type and object_index is 
encoded in an object_id. object_id is an unique identifier for every object.

texture_index and texture_type, similarly to object_index and object_type, point to a texture 
and specifies what kind of texture it is respectively. Similarly to object_index and object_type,
texture_index and texture_type is consolidated into a texture_id. texture_type can have the flag
is_sampled which means the texture is sampled. If not then the texture is procedurally generated.

Procedural textures are single function files which takes in a vec3 position and returns a vec4 color.
These functions are written in a seperate file and inserted into this file by the preprocessor. 
The function's name should be "procedural_texture".
 

LONG TERM GOALS
===============

    - Add detail when standing still -- DONE --

    - Add skybox

    - Add surface textures -- ALMOST --

    - Make set theory functions possible with objects like add and subtract 
        (can see insides of objects)

    - Subfurface scattering

    - Add lighting -- BASIC --

    - Make a real time ray tracer with triangle geometry (will be scuffed) -- ALMOST --

    - Implement meshlets for more dynamic materials and better culling (for traingles)

    - Simulate glass of beer

*/


// Invocations in the (x, y, z) dimension
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// PRE PROCESSOR STUFF

/*
Different methods to avoid self intersection
    - method 0: Proposed in Ray Tracing Gems.
        Use a custom function to offset intersection point when creating a new ray.
        My implementation doesn't seem to work correctly as it produces some nasty artifacts.
        Some of them are:
         -visible lines in noise when multisampling is disabled
         -weird lines on a center circle in the random scene
         -being a little more expensive to run
         -darker colors, although that might be more correct
    - method 1: Proposed in Ray tracing in a weekend. 
        Simply sets range for valid t values a little above zero.
        TODO Preferred method until I get method 0 to work properly     
*/
#define self_intersect_method 1

#if self_intersect_method == 1
#define NEW_RAY_START 0.0001
#elif self_intersect_method == 0
#define NEW_RAY_START 0.0
#endif

/*
// Fun fact, I made it the fuck up
Refraction tracking is the practice of answering the question, 
if I enter 3 transparant objects, when I leave only one, what material am I in.
Refraction tracking solves this by assigning a refraction depth value to all materials,
and choosing the material with the lowest depth when leaving an object inside of another/others.

This should, in theory, come with the abiltiy to cut objects with another object that has
air as its material. It also allows for composite glass objects; Rays will travel through multiple
transparent objects with the same material as if it was one homogenous mass, 
although at a higher ray depth cost (It might not get out if max_default_depth is low).

Enabling refraction tracking has a small performance impact
*/
#define use_refraction_tracking 1

// Emissive materials
#define USE_EMISSION 0

/*
This is what will happen. also i think mesh = scene
1. X  I will make a mesh class inherited from PTScene ( or just use PTScene).
2. X  I will add support for nested scene like objects. BVHs will be able to be glued together in 
a way that all objects still will be drawn.

3. Yes These meshes will have their own transforms. Meshes store transform_index'es to transforms 
in an array. Meshes will probably need to send their own rayhits, then copy over relevant
information when the ray caster goes up the bvh tree; Points and normals need to be transformed
back.

Spheres which need to be stretched or rotated are meshes with one object with default values. 

Spheres will use the old structure.

*/
#define USE_INSTANCING 1


// CONSTANTS
// =========
const int int_limit = 2147483647;
const int neg_int_limit = -2147483648;
const int all_ones = -1;
const float infinity = 1. / 0.;
const double pi_d = 3.1415926535897932385;
const float pi = 3.1415926535897932385;
const float pi_half = pi / 2.;
const float pi_double = pi * 2;
const float eps = 1e-6;

// Used by offset_ray function
const float origin = 1.0 / 32.0;
const float float_scale = 1.0 / 65536.0; 
const float int_scale = 256.0;

// object_type enumerator
// From now on, the object_type is encoded as the first byte of an object_id
const int is_not_obj = 0;
const int is_sphere = 1;
const int is_plane = 2;
const int is_triangle = 3;

// texture_type enumerator
const int is_sampled = 1;
const int is_spatial = 2;

const int is_procedural_flat = 0; // For uv procedural functions
const int is_procedural_spatial = 2; // For point hit procedural function
const int is_sampled_texture = 1; // For uv sampling from texture buffer
const int is_no_texture = 4;

const int MAX_TEXTURE_COUNT = 512;

// Keeps values of inside_of neatly organized
struct InsideOf {
    int material_index;
    int refraction_depth;
};

// IORs
const float IOR_air = 1.0;
float current_IOR = IOR_air;

// The program will keep track of which objects a ray has passed through to do correct calculations
//  i.e. refraction tracking
// This is the maximum amount of overlapping geomtry that will be considered
const int max_refraction_depth = 8;

// Keeps track of first vacant index in stack
int inside_of_count = 0;

InsideOf empty_inside() {
    return InsideOf(0, int_limit - 1);
}

// Holds the object_id, obejct_type and refraction_depth of and object
InsideOf inside_of[max_refraction_depth] = InsideOf[](
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside()
);
// TODO: Add support for cpu to send InsideOf buffer based on camera position

#if !USE_EMISSION
const vec4 default_color = vec4(0.7, 0.7, 0.9, 1);
#endif

#if USE_EMISSION
const vec4 default_color = vec4(0);
bool is_emissive = false;
#endif

const int max_depth = 64 * 16; // Length of rayhits to visit stack in BVH 
int refraction_bounces = 0; // Counts the number of times a ray has refracted
int node_hit_count = 0;
int object_hit_count = 0;

// Maximum number of inner nodes a BVHNode can have
const int order = 2; // Replaced by script preprocessor, do NOT touch this line

// Flags
const int flag_size = 31;
const int starting_bit = int(pow(2, flag_size - 1));
bool flags[flag_size];

bool use_bvh;
bool show_bvh_depth;
bool show_node_count;
bool show_object_count;

bool multisample;

// Random
// Code snippets taken from Ray tracer demo by HK-SHAO
struct Random {
    float seed;
    float value;
};

Random random = Random(42, 0);

// DATATYPES
// =========
struct Camera {
    vec3 pos;
    float focal_length;
    vec3 right;
    float viewport_width;
    vec3 up;
    float viewport_height;
    vec3 forward;
    float gamma;
};

struct Ray {
    vec3 origin;
    float start;
    vec3 direction;
    float end;
};

struct Material {
    // How much of the light between zero and one is reflected for each color, 
    // zero being black
    vec3 albedo; 
    // How much the reflections scatter 
    float roughness; 
    // IDK what this means, metal n stuff, 1 is metal, 0 is dielectric
    float metallic;

    // Value between 0 and 1 where 0 is fully opaque and 1 is fully transparent.
    // Values inbetween determine the energy loss per unit length. 
    // Non-opaque materials can refract.
    float opacity;
    float reflectivity;
    // Index of refraction
    float IOR;
    // In cases where a translusent object intersects other objects or contains other translusent 
    //  objects, the refraction_depth will determine which object's material will take precedence 
    //  in the intersection
    int refraction_depth;
    bool is_emissive;
    int temp2;
    int temp3;
    int temp4;
    int temp11;
    int temp21;
    int temp31;
};

// The materials stored in objects are indices to a global material array
struct Plane {
    vec3 normal;
    float d;
    int mtl_index;
    int texture_id;
    int filler0;
    int filler1;
};

#if !USE_INSTANCING
struct Sphere {
    vec3 center;
    float radius;
    int mtl_index;
    int texture_id;
    int filler0;
    int filler1;
    
    int filler2;
    int filler3;
    int filler4;
    int filler5;
    int filler11;
    int filler12;
    int filler13;
    int filler14;
};
#endif

#if USE_INSTANCING
struct Sphere {
    vec3 col0;
    int mtl_index;
    vec3 col1;
    int texture_id;
    vec3 col2;
    int filler0;
    vec3 col3;

    int filler1;
};
#endif

struct Triangle {
    // TODO SO MUCH SPACE OPTIMIZATION
    vec3 point1;
    float filler1;
    vec3 point2;
    float filler2;
    vec3 point3;
    float filler3;
    vec3 normal;
    float filler4;

    int mtl_index;
    int texture_id;
    int filler0;
    int filler5;
};

struct RayHit {
    // Stored on-hit
    bool hit;
    int object_id;

    // Retrieved later
    vec2 uv;
    vec3 point;
    int mtl_index;
    vec3 normal;
    int texture_id;
    vec4 color;
};

struct AABB {
    // only xyz is used, they are vec4 to fit memory allocation
    // minimum.x < maximum.x etc. should always be true.
    // The w value is unused by the aabb, so it can be filled with whatever is useful
    vec4 minimum;
    vec4 maximum;
};


// node_index and size are hidden inside the aabb struct
#define NODE_node_index floatBitsToInt(node.bbox.minimum.w)
#define NODE_node_size floatBitsToInt(node.bbox.maximum.w)
struct BVHNode {
    // NOTE: Remember that AABB stores FLOATS, not ints
    AABB bbox; 
};


// BUFFERS
// =======
layout(rgba32f, set = 0, binding = 0) uniform restrict image2D output_image;

layout(set = 1, binding = 0, std430) restrict readonly buffer LODBuffer {
    int width;
    int height;
    int samples_per_pixel; // How many rays are sent per pixel, DEPRECATED
    int max_default_depth; // How many bounces is sampled, for normal rays
    int max_refraction_bounces; // How many total extra bounces can occur on refraction
} LOD;

// Materials
layout(set = 2, binding = 0, std430) restrict readonly buffer MaterialBuffer {
    Material data[];
} materials;

// Objects
layout(set = 2, binding = 1, std430) restrict readonly buffer SpheresBuffer {
    Sphere data[];
} spheres;

layout(set = 2, binding = 2, std430) restrict readonly buffer PlanesBuffer {
    Plane data[];
} planes;

layout(set = 2, binding = 3, std430) restrict readonly buffer TrainglesBuffer {
    Triangle data[];
} triangles;

layout(set = 3, binding = 0, std430) restrict readonly buffer BVH_List {
    BVHNode list[];
} BVH;

layout(set = 3, binding = 1, std430) restrict readonly buffer Object_ID {
    int list[];
} object_ids;

layout(set = 4, binding = 0, std430) restrict readonly buffer TriangleVertex {
    float data[];
} triangle_vertices;

layout(set = 4, binding = 1, std430) restrict readonly buffer TriangleUV {
    float data[];
} triangle_uvs;

layout(set = 4, binding = 2, std430) restrict readonly buffer TriangleIndex {
    float data[];
} triangle_indices;

layout(set = 5, binding = 0) uniform sampler2D Textures[MAX_TEXTURE_COUNT];

layout(push_constant, std430) restrict readonly uniform constants {
    Camera camera;
    int flags;
    int image_offset_x; // How many pixels offset should the viewport origin be
    int image_offset_y; 
    int node_count_threshold;
    int object_count_threshold;
    float time;
    float frame;
    float max_samples;
} push;

// UTILITY FUNCTIONS
// =================

RayHit empty_rayhit() {
    return RayHit(false, 0, vec2(0), vec3(0), 0, vec3(0), 0, vec4(0));
}

float atan2(float y, float x) {
    // Apparantly more stable atan function, read:
    // https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle

    bool s = (abs(x) > abs(y));
    return mix(pi / 2.0 - atan(x,y), atan(y,x), s); // Should perform as well as ternary
}

float reflectance(float eta, float cos_theta) {
    // Schlick's approximation for reflectivety
    float r0 = (1. - eta) / (1. + eta);
    r0 = r0 * r0;
    return r0 + (1. - r0) * pow(1. - cos_theta, 5.);
}

// Random functions
float rand(float seed) {
    return fract((seed * 23489.52364) / 0.0836);
}

float noise(inout Random r) {
    // Also taken from Ray Tracer Demo by HK-SHAO
    r.value = fract(sin(r.seed++) * 43758.5453123);
    return r.value;
}

float rand2(vec2 co) { 
  return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

vec3 rand_vec3(vec3 point) {
    // Creates a normalized vector in a random direction from a point
    vec3 n = vec3(
        rand(noise(random)) - 0.5, 
        rand(noise(random)) - 0.5, 
        rand(noise(random)) - 0.5);

    return normalize(n);
}

float hash(vec3 x) {
    // Also taken from Ray Tracer Demo by HK-SHAO
    uvec3 p = floatBitsToUint(x);
    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));
    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));
    uint n = h32 ^ (h32 >> 16U);
    return float(n) * (1.0 / float(0x7fffffff));
}

void swap(inout float a, inout float b) {
    // Swap the values of two floats
    a = a + b;
    b = a - b;
    a = a - b;
}

bool is_close(float value1, float value2) {
    // TODO COnsider implementing this algorithm:
    // https://stackoverflow.com/questions/4915462/how-should-i-do-floating-point-comparison
    // Whether a value is within an epsilon of value2
    return (value2 + eps > value1 && value1 > value2 - eps);
}

bool near_zero(vec3 vec) {
    // Whether a vec3 is close to zero in all fields
    return (abs(vec.x) < eps && abs(vec.y) < eps && abs(vec.z) < eps);
}

bool near_zero(float f) {
    return (abs(f) < eps);
}

vec3 offset_ray(const vec3 point, const vec3 normal) {
    // Calculates a new point for ray intersection, which stops self intersection
    // Implementation of algorithm in Ray Tracing Gems chapter 6.2.2.4
    ivec3 offset = ivec3(normal * int_scale);
    vec3 point_offset = vec3(
        intBitsToFloat(floatBitsToInt(point.x) + ((point.x < 0.) ? -offset.x : offset.x)),
        intBitsToFloat(floatBitsToInt(point.y) + ((point.y < 0.) ? -offset.y : offset.y)),
        intBitsToFloat(floatBitsToInt(point.z) + ((point.z < 0.) ? -offset.z : offset.z))
    );
    return vec3(
        abs(point.x) < origin ? point.x + float_scale * normal.x : point_offset.x,
        abs(point.y) < origin ? point.y + float_scale * normal.y : point_offset.y,
        abs(point.z) < origin ? point.z + float_scale * normal.z : point_offset.z
    );
}

bool in_range(float value, Ray ray) {
    // Is value in range inclusively start and stop values
    return (ray.start <= value && ray.end >= value);
}

bool xin_range(float value, Ray ray) {
    // Is value in range exclusively start and stop values
    return (ray.start < value && ray.end > value);
}

vec3 ray_at(Ray ray) {
    return ray.origin + ray.direction * ray.end;
}

vec3 ray_at(Ray ray, float t) {
    return ray.origin + ray.direction * t;
}

void parse_flags() {
    int bit = starting_bit;
    int num = push.flags;
    // Loop over the i-th bit from most significant to least
    for (int i = flag_size - 1; i >= 0; i--) {
        num -= bit;
        if (num < 0) {
            flags[i] = false;
            num += bit;
        } else {
            flags[i] = true;
        }
        bit = bit >> 1;
    }

    use_bvh = flags[0];
    show_bvh_depth = flags[1];
    multisample = flags[2];
    show_node_count = flags[3];
    show_object_count = flags[4];
}

int get_object_type(int object_id) {
    return object_id >> 24;
}

int get_object_index(int object_id) {
    const int three_last_bytes = int_limit >> 8;
    return object_id & three_last_bytes;
}

int get_texture_type(int texture_id) {
    return texture_id >> 30;
}

int get_texture_index(int texture_id) {
    const int thirty_last_bits = int_limit >> 2;
    return texture_id & thirty_last_bits;
}


// TEXTURE STUFF
// =============

vec2 sphere_get_uv(vec3 pos) {
    float theta = acos(pos.y);
    float phi = atan(-pos.z, pos.x) + pi;

    vec2 uv = vec2(phi / pi_double, theta / pi);

    return uv;
}

// Preprocessor will place procedural function definitions here
//procedural_texture_function_definition_hook

vec4 procedural_texture(vec3 pos, int function) {
    // This function will be pre processed and filled procedural texture functions.
    // For sampled textures there is a different implementation (not yet implemented)
    
    // Return white as default function
    if (function == 0) {
        return vec4(1);
    }
    
    // Preprocessor will insert procedural texture functions here
    //procedural_texture_function_call_hook

    // Return black when function not found
    return vec4(0);
}


vec4 get_texture(RayHit rayhit) {
    int texture_type = get_texture_type(rayhit.texture_id);
    int texture_index = get_texture_index(rayhit.texture_id);
    vec3 sampled_point = (texture_type & is_spatial) > 0 ? rayhit.point : vec3(rayhit.uv, 0);
    
    // TODO Support for texture_index to work on objects properly 
    return texture(Textures[3], rayhit.uv);
    if ((texture_type & is_sampled) > 0) {
        return texture(Textures[3], rayhit.uv);
    }
    
    return procedural_texture(sampled_point, texture_index);
}


// RAY-HIT FUNCTIONS
// =============

vec4 hit_skybox(Ray ray, inout RayHit rayhit) {
    // TODO: Implement skybox texture and hit detection
    return default_color;
}

float hit_AABB(Ray ray, AABB bbox, vec3 inv_dir, bvec3 is_dir_neg) {
    // I think I got this implementation from stackoverflow, but I forgot where from
    node_hit_count++;
    // Returns true if ray hits aabb within given range
    for (int i = 0; i < 3; i++) {
        float t0 = ((bbox.minimum[i] - ray.origin[i]) * inv_dir[i]);
        float t1 = ((bbox.maximum[i] - ray.origin[i]) * inv_dir[i]);

        // Make sure t0 is smallest
        if (is_dir_neg[i]) {swap(t0, t1);}

        if (t0 > ray.start) {ray.start = t0;}
        if (t1 < ray.end) {ray.end = t1;}

        if (ray.end <= ray.start) {return -1.0;}
    }
    // But if ray origin is inside the box shouldn't ray.start be negative?
    return ray.start; // t value of ray intersecting the bounding box
    // return (ray.start > 0.0) ? ray.start : ray.end; // t value of ray intersecting the bounding box
}

#if !USE_INSTANCING 
RayHit hit_sphere(inout Ray ray, int object_id, inout RayHit rayhit) {

    Sphere sphere = spheres.data[get_object_index(object_id)];
    // Calculate the determinant of quadratic formula
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float discriminant = half_b * half_b - a*c;

    // Early return if ray does not hit
    if (discriminant < 0.) {
        return rayhit;
    } 

    float sqrtd = sqrt(discriminant);
    float root = (-half_b - sqrtd) / a;

    // If root is within a valid t range and less than previous rayhit
    if (!in_range(root, ray)) {
        root = (-half_b + sqrtd) / a;
        if (!in_range(root, ray)) {
            return rayhit;
        }
    }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    ray.end = root;
    
    rayhit.normal = (ray_at(ray, root) - sphere.center) / sphere.radius;

    return rayhit;
}
#endif

#if USE_INSTANCING
RayHit hit_sphere(inout Ray ray, int object_id, inout RayHit rayhit) {

    Sphere sphere = spheres.data[get_object_index(object_id)];

    // DO MATREIX CALC
    mat4 matrix = mat4(sphere.col0, 0, sphere.col1, 0, sphere.col2, 0, sphere.col3, 1);

    Ray temp_ray = Ray(vec3(matrix * vec4(ray.origin, 1)), ray.start, vec3(matrix * vec4(ray.direction, 0)), ray.end);

    // Calculate the determinant of quadratic formula
    vec3 oc = temp_ray.origin;
    float a = dot(temp_ray.direction, temp_ray.direction);
    float half_b = dot(oc, temp_ray.direction);
    float c = dot(oc, oc) - 1.0;

    float discriminant = half_b * half_b - a*c;

    // Early return if ray does not hit
    if (discriminant < 0.) {
        return rayhit;
    } 

    float sqrtd = sqrt(discriminant);
    float root = (-half_b - sqrtd) / a;

    // If root is within a valid t range of ray and less than previous rayhit
    if (!in_range(root, ray)) {
        root = (-half_b + sqrtd) / a;
        if (!in_range(root, ray)) {
            return rayhit;
        }
    }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    ray.end = root;
    
    // NOTE: We don't have to set point here because t values will work both before and after transform
    rayhit.normal = normalize(vec3(vec4(ray_at(temp_ray, root), 0) * matrix) );

    return rayhit;
}
#endif

RayHit hit_spheres(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope sphere array to bypass function parameter limitations
    for (int i = 0; i < spheres.data.length(); ++i) {
        hit_sphere(ray, i + (is_sphere << 24), rayhit);
    }
    return rayhit;
}

RayHit hit_plane(inout Ray ray, int object_id, inout RayHit rayhit) {
    
    Plane plane = planes.data[get_object_index(object_id)];

    float intersection_t = ((plane.d - dot(ray.origin, plane.normal)) /
                            dot(plane.normal, ray.direction));

    // Early return if plane is paralell, even if the ray is contained in the plane
    if (isnan(intersection_t) || (isinf(intersection_t))) {
        return rayhit;
    }

    // Early return if t is not in range of ray
    if (!in_range(intersection_t, ray)) {
        return rayhit;
    }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    ray.end = intersection_t;

    return rayhit;
}

RayHit hit_planes(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope planes array to bypass function parameter limitations
    for (int i = 0; i < planes.data.length(); ++i) {
        hit_plane(ray, i + (is_plane << 24), rayhit);
    }
    return rayhit;
}


// RAY-TRIANGLE INTERSECTION FUNCTIONS
// ===================================

// TODO Compare branched vs branchless when support for importing meshes 
bool hit_triangle_MT_branchless(inout Ray ray, int object_id, inout RayHit rayhit) {
    // Implementation of the Moller-Trumbore algorithm made by BrunoLevy, fitted to project
    // https://stackoverflow.com/a/42752998

    int triangle_index = get_object_index(object_id);

    vec3 A = triangles.data[triangle_index].point1;
    vec3 B = triangles.data[triangle_index].point2;
    vec3 C = triangles.data[triangle_index].point3;

    vec3 E1 = B-A;
    vec3 E2 = C-A;
    vec3 N = cross(E1,E2);
    float det = -dot(ray.direction, N);
    float invdet = 1.0 / det;
    vec3 AO  = ray.origin - A;
    vec3 DAO = cross(AO, ray.direction);
    float u =  dot(E2,DAO) * invdet;
    float v = -dot(E1,DAO) * invdet;
    float t =  dot(AO,N)  * invdet;

    // NOTE: CAN BE OPTIMIZED LATER
    if ((det >= 1e-6 && in_range(t, ray) && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0)) {
        rayhit.hit = true;
        rayhit.object_id = object_id;
        ray.end = t;
        return true;
    }

    return false;
}

bool hit_triangle_MT(inout Ray ray, int object_id, inout RayHit rayhit) {
    // Implementation of the Moller-Trumbore algorithm made by BrunoLevy, fitted to project
    // https://stackoverflow.com/a/42752998

    int triangle_index = get_object_index(object_id);

    vec3 A = triangles.data[triangle_index].point1;
    vec3 B = triangles.data[triangle_index].point2;
    vec3 C = triangles.data[triangle_index].point3;
    
    vec3 E1 = B-A;
    vec3 E2 = C-A;
    vec3 N = cross(E1,E2);
    float det = -dot(ray.direction, N);
    // TODO Add global backface cull flag and object flag

    // If ray is parallel to triangle plane
    if (near_zero(det)) {
        return false;
    }

    float invdet = 1.0 / det;
    vec3 AO = ray.origin - A;
    float t = dot(AO,N) * invdet;

    if (!in_range(t, ray)) {
        return false;
    }

    vec3 DAO = cross(AO, ray.direction);
    float u = dot(C - A, DAO) * invdet;
    float v = -dot(B - A, DAO) * invdet;

    if (u >= 0.0 && v >= 0.0 && (u+v) <= 1.0) {
        rayhit.hit = true;
        rayhit.object_id = object_id;
        ray.end = t;
        return true;
    }

    return false;
}

RayHit hit_triangles(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope planes array to bypass function parameter limitations
    for (int i = 0; i < triangles.data.length(); ++i) {
        hit_triangle_MT(ray, i + (is_triangle << 24), rayhit);
    }
    return rayhit;
}

void hit_object(inout Ray ray, inout RayHit rayhit, int object_id) {
    // Chooses the appropriate hit_ function for given object_type
    int object_type = get_object_type(object_id);
    object_hit_count++;

    if (object_type == is_sphere) {
        hit_sphere(ray, object_id, rayhit);
    } else if (object_type == is_triangle) {
        hit_triangle_MT(ray, object_id, rayhit);
    }
}


// OTHER RAY FUNCTIONS
// ===================

RayHit determine_rayhit(Ray ray_in, inout RayHit rayhit) {
    // Resolves intersextion point, normal and other information from rayhit 
    rayhit.point = ray_at(ray_in);

    int object_type = get_object_type(rayhit.object_id);
    int object_index = get_object_index(rayhit.object_id);

    // Procedure for hitting sphere
    if (object_type == is_sphere) {
        Sphere sphere = spheres.data[object_index];
        rayhit.mtl_index = sphere.mtl_index;
        rayhit.texture_id = sphere.texture_id;
        // TODO NOTE For rotated spheres we would use the normal prior to the world space transformation
        rayhit.uv = sphere_get_uv(rayhit.normal);

    // Procedure for hitting plane
    } else if (object_type == is_plane) {
        Plane plane = planes.data[object_index];
        rayhit.mtl_index = plane.mtl_index;
        rayhit.texture_id = plane.texture_id;
        rayhit.normal = plane.normal;
    
    // Procedure for hitting triangle
    } else if (object_type == is_triangle) {
        Triangle triangle = triangles.data[object_index];
        rayhit.mtl_index = triangle.mtl_index;
        rayhit.texture_id = triangle.texture_id;
        rayhit.normal = dot(triangle.normal, ray_in.direction) > 0 ? -triangle.normal : triangle.normal;
    }

    rayhit.color = vec4(materials.data[rayhit.mtl_index].albedo, 1);
    #if USE_EMISSION
    is_emissive = materials.data[rayhit.mtl_index].is_emissive;
    #endif
    return rayhit;
}

RayHit check_ray_hit(inout Ray ray) {
    RayHit rayhit = empty_rayhit();

    hit_spheres(ray, rayhit);
    hit_triangles(ray, rayhit);
    hit_planes(ray, rayhit);

    return rayhit;
}

RayHit check_ray_hit_BVH(inout Ray ray) {
    RayHit rayhit = empty_rayhit();

    // NOTE: Objects that go before bvh can be used as Occluders
    hit_planes(ray, rayhit);

    // Pre-compute values for hit detection
    vec3 inv_direction = vec3(1. / ray.direction.x, 1. / ray.direction.y, 1. / ray.direction.z);
    bvec3 dir_is_negative = bvec3(inv_direction.x < 0., inv_direction.y < 0., inv_direction.z < 0.);

    // Stack of indices of nodes yet to traverse
    // NOTE: might need to be bigger for larger scenes and/or with higher order trees
    int to_visit[max_depth];
    to_visit[0] = 0;

    float to_visit_t[max_depth];

    // Test if root node is hit by ray
    float tmp = hit_AABB(ray, BVH.list[0].bbox, inv_direction, dir_is_negative);
    to_visit_t[0] = tmp;

    // Index to top of the stack, points to vacant spot ABOVE the stack
    int to_visit_i = (in_range(tmp, ray)) ? 1 : 0;

    // Index to current node being processed
    int current_index = 0;

    int temp_children[order];
    float temp_ts[order];

    for (int h = 0; h < order; h++) {
        temp_ts[h] = infinity;
    }
        
    while (to_visit_i > 0 && to_visit_i <= max_depth) {
        current_index = to_visit[--to_visit_i];
        BVHNode node = BVH.list[current_index];
        int node_index = NODE_node_index;
        int node_size = NODE_node_size;

        /*
        All nodes in to_visit should be in sorted order, 
         we can break if the last node is out of range
        NOTE: This is MUCH slower
        */
        // if (!in_range(to_visit_t[to_visit_i], ray)) {
        //     break;
        // }

        // If node is leaf node, hit all children
        // node_index pointing to nodes should never be zero (root_node)
        if (node_index <= 0) {
            for (int k = 0; k < node_size; k++) {
                hit_object(ray, rayhit, object_ids.list[abs(node_index) + k]);
            }
            continue;
        }

        int added_children = 0;
        // Do hit check on child inner nodes and add them to temp array
        for (int l = 0; l < node_size; l++) {
            float aabb_t = hit_AABB(ray, BVH.list[node_index + l].bbox, inv_direction, dir_is_negative);
            // xin_range much faster, but has an artifact
            if (in_range(aabb_t, ray)) {
                added_children++;
                temp_ts[l] = aabb_t;
                temp_children[l] = node_index + l;
            }
        }

        // TODO COnsider min heap or insertion sort
        // Add nodes to stack in a sorted order
        to_visit_i += added_children;
        for (int i = 0; i < added_children; i++) { // Looping over constant is not faster here
            // Finds smallest t, closest box
            float smallest_t = infinity;
            int smallest_index = order;
            for (int j = 0; j < order; j++) { // Looping over constant is faster here
                if (temp_ts[j] < smallest_t ) {
                    smallest_t = temp_ts[j];
                    smallest_index = j;
                }
            }

            // Zero out the smallest
            temp_ts[smallest_index] = infinity;
            to_visit[to_visit_i - i - 1] = temp_children[smallest_index];
            to_visit_t[to_visit_i - i - 1] = smallest_t;
        }        
    }

    return rayhit;
}

// RAY-BOUNCE FUNCTIONS
// ====================
Ray reflect_ray(Ray ray_in, RayHit rayhit) {
    // Returns a new reflected ray based on ray_in and rayhit
    
    vec3 new_origin = rayhit.point;

    #if self_intersect_method==0
    new_origin = offset_ray(rayhit.point, rayhit.normal);
    #endif

    float metallic = materials.data[rayhit.mtl_index].metallic;

    vec3 reflected_dir = reflect(ray_in.direction, rayhit.normal) * metallic;
    vec3 dir_offset = rand_vec3(rayhit.point) * (1. - metallic);

    vec3 ray_dir = reflected_dir + dir_offset;
    
    // Reflects ray if it points into the object
    if (dot(ray_dir, rayhit.normal) < 0.) {
        ray_dir = reflect(ray_dir, rayhit.normal);
    }

    return Ray(new_origin, NEW_RAY_START, ray_dir, infinity);
}

// TODO Experiment with max heap instead of array
int get_material(int material_index, int lowest_depth, bool ignore_self) {
    // Loop over materials that we have entered and not left, 
    //  pick the one with the lowest refraction_depth, ignore default values if specified
    int current_index = material_index;
    for (int i = 0; i < max_refraction_depth; i++) {
        InsideOf index = inside_of[i];
        if (index.refraction_depth < lowest_depth) {
            if (!(material_index == index.material_index) || !ignore_self) {
                lowest_depth = index.refraction_depth;
                current_index = index.material_index;
            } else {
                // same material is true, we ignore the same material one time
                ignore_self = false;
            }
        }
    }

    return current_index;
}

void remove_object_from_inside_of(int material_index) {
    int shift = 0;
    // NOTE: inside_of_count tested to be faster than looping over entire array
    for (int i = 0; i < inside_of_count; i++) {
        InsideOf index = inside_of[i];
        if (material_index == index.material_index) {
            shift = 1;
        }
        inside_of[i] = inside_of[i + shift];
    }
    inside_of_count--;
}

Ray refract_ray(Ray ray_in, inout RayHit rayhit) {
    // Returns a refracted or reflected ray based on ray_in and rayhit
    // TODO: Add support for cpu to send InsideOf buffer based on camera position
    // TODO: Add tiny random direction change coupled with color shift, prism, diffraction
    // TODO Add support for meshes to refract
    // TODO: Implement Beer's law:
    // https://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_3_Refractions_and_Beers_Law.shtml 
    
    vec3 new_origin = rayhit.point;

    // Whether object is inside the current object
    bool is_inside = bool(dot(rayhit.normal, ray_in.direction) > 0.);
    vec3 normal = (is_inside) ? -rayhit.normal : rayhit.normal;

    float eta_in = current_IOR;

    Material material = materials.data[rayhit.mtl_index];

    #if use_refraction_tracking==0
    float eta_out = (is_inside) ? IOR_air : material.IOR;
    float eta = eta_in / eta_out;
    #endif

    #if use_refraction_tracking==1
    // If ray is inside object ignore rayhti.mtl_index as having a possible eta_out, else
    //  rayhit.mtl_index is default material if no other materials are in inside_of.
    int depth = is_inside ? int_limit : material.refraction_depth;
    int current_material = get_material(rayhit.mtl_index, depth, is_inside);

    float eta_out = materials.data[current_material].IOR;
    float eta = eta_in / eta_out;

    // If ratio is one the ray will travel in a straight line
    if (is_close(eta, 1.0)) {
        // If ray was inside and went out, remove from inside_of list
        if (is_inside) {
            remove_object_from_inside_of(rayhit.mtl_index);
        } else {
            // If ray was outside and refracted, add to inside_of list
            inside_of[inside_of_count++] = InsideOf(rayhit.mtl_index, material.refraction_depth);
        }
    
        #if self_intersect_method==0
        new_origin = offset_ray(new_origin, -normal);
        #endif

        // TODO Only invalidate color if this object has the same color as the previous object
        rayhit.hit = false;

        // Add extra available bounces when ray refracts/goes through another object
        if (refraction_bounces < LOD.max_refraction_bounces - 1) {refraction_bounces++;}

        return Ray(new_origin, NEW_RAY_START, ray_in.direction, infinity);
    }
    #endif

    vec3 normalized_direction = normalize(ray_in.direction);

    // Calculate whether angle is shallow enough to disallow refraction
    float cos_theta = min(dot(-normalized_direction, normal), 1.);
    float sin_theta = sqrt(1. - cos_theta * cos_theta);
    bool cannot_refract = eta * sin_theta > 1.;

    // Check for internal reflection
    if ((reflectance(eta, cos_theta) * (material.reflectivity) > noise(random)) || cannot_refract) {
        #if self_intersect_method==0
        return Ray(offset_ray(new_origin, normal), NEW_RAY_START, reflect(normalized_direction, normal), infinity);
        #endif

        #if self_intersect_method==1
        return Ray(new_origin, NEW_RAY_START, reflect(normalized_direction, normal), infinity);
        #endif
    } 

    current_IOR = eta_out;

    #if use_refraction_tracking==1
    // If ray was inside and went out, remove from inside_of list
    if (is_inside) {
        remove_object_from_inside_of(rayhit.mtl_index);
    } else {
        // If ray was outside and refracted, add to inside_of list
        inside_of[inside_of_count++] = InsideOf(rayhit.mtl_index, material.refraction_depth);
    }
    #endif

    #if self_intersect_method==0
    new_origin = offset_ray(new_origin, -normal);
    #endif

    // Add extra available bounces when ray refracts/goes through another object
    if (refraction_bounces < LOD.max_refraction_bounces - 1) {refraction_bounces++;}
    
    return Ray(new_origin, NEW_RAY_START, refract(normalized_direction, normal, eta), infinity);
}

Ray scatter_ray(Ray ray_in, RayHit rayhit) {
    // TODO Change the way rays are created based on roughness, less/ more scatter

    #if self_intersect_method==0
    vec3 new_origin = offset_ray(rayhit.point, rayhit.normal);
    #endif

    #if self_intersect_method==1
    vec3 new_origin = rayhit.point;
    #endif

    // Returns a scattered ray based on ray_in and rayhit
    vec3 ray_dir = rand_vec3(new_origin + ray_in.direction) + rayhit.normal;

    // If created ray pointed in opposite direction of normal
    ray_dir = near_zero(ray_dir) ? rayhit.normal : ray_dir;

    // Make sure reflected ray points in the same way as normal
    ray_dir = dot(ray_dir, rayhit.normal) < 0. ? ray_dir * -1.0 : ray_dir;

    return Ray(new_origin, NEW_RAY_START, ray_dir, infinity);
}

Ray bounce_ray(Ray ray_in, inout RayHit rayhit) {
    // Creates a new ray based material properties from the previous rayhit

    // TODO Make more sophisticated function choosing
    if (materials.data[rayhit.mtl_index].opacity < 1.) {
        return refract_ray(ray_in, rayhit);
    }

    if (materials.data[rayhit.mtl_index].metallic > 0.) {
        return reflect_ray(ray_in, rayhit);
    }

    return scatter_ray(ray_in, rayhit);
}

// MAIN FUNCTIONS
// ==============
vec4 cast_ray(Ray ray) {
    // Casts a ray with bounces and returns the color of the ray

    // Turns out computing colors in the same loop was faster, TODO maybe reconsider

    // Calculate rayhits
    Ray new_ray = ray;
    RayHit rayhit;
    refraction_bounces = 0;
    vec4 new_color = vec4(1);
    vec4 tex_col = vec4(1);

    // MICRO-OPT Having the loop be static/const is slightly faster than with having it dynamic
    for (int i = 0; i < LOD.max_default_depth + refraction_bounces; i++) {
        if (use_bvh) {
            rayhit = check_ray_hit_BVH(new_ray);

            // Send one ray, skip bouncing
            if (show_bvh_depth) {
                float a = show_node_count ? float(node_hit_count) / float(push.node_count_threshold) : 0.0;
                float b = show_object_count ? float(object_hit_count) / float(push.object_count_threshold) : 0.0;
                rayhit.color = (max(a, b) > 1.0) ? vec4(1) : vec4(b, 0, a, 0);
                new_color = rayhit.color;
                break;
            }
        } else {
            rayhit = check_ray_hit(new_ray);
        }

        // TODO Try using continues instead
        // Early break if no hit
        if (!rayhit.hit) {
            // Adds sky color as the last rayhit when miss
            rayhit.color = hit_skybox(ray, rayhit);
            new_color *= rayhit.color;
            break;
        }

        determine_rayhit(new_ray, rayhit);

        #if USE_EMISSION
        if (is_emissive) {
            new_color *= rayhit.color;
            break;
        } else {is_emissive = false;} // This never does anything
        #endif

        // Get texture color
        tex_col = get_texture(rayhit);

        new_ray = bounce_ray(new_ray, rayhit);

        // TODO: implement attenuation based on incident and exiting angles
        
        // Rayhit is invalidated if the ray goes through two transparent objects with the same material 
        if (rayhit.hit) {
            new_color *= rayhit.color * tex_col;
        }
    } 

    return new_color;
}


// The code we want to execute in each invocation
void main() {

    // VARIABLE DEFINITIONS
    // ====================

    // Calculate the vectors across the horizontal and down the vertical viewport edges.
    const vec3 viewport_u = push.camera.right * push.camera.viewport_width;
    const vec3 viewport_v = -push.camera.up * push.camera.viewport_height;

    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
    const vec3 pixel_delta_u = viewport_u / LOD.width;
    const vec3 pixel_delta_v = viewport_v / LOD.height;

    // Calculate the location of the upper left pixel.
    const vec3 viewport_upper_left = push.camera.pos - push.camera.forward * push.camera.focal_length -
                                     (viewport_u + viewport_v) / 2.;

    const vec3 pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);

    // gl_GlobalInvocationID uniquely identifies this invocation across all work groups
    // const uvec3 UVu = gl_GlobalInvocationID + uvec3(push.image_offset, 0);
    const ivec3 UVi = ivec3(gl_GlobalInvocationID) + ivec3(push.image_offset_x, push.image_offset_y, 0);
    const vec3 UV = vec3(UVi);

    const vec3 pixel_center = pixel00_loc + (UV.x * pixel_delta_u) + (UV.y * pixel_delta_v);

    random.seed = hash(vec3(UV.xy, push.time));

    // Initialize render flags
    parse_flags();

    // CODE
    // ====

    // Create ray with offset
    vec3 offset = (pixel_delta_u / 2) * (rand(float(push.time)) - 1.) + 
                  (pixel_delta_v / 2) * (rand(float(push.time)) - 1.);
    vec3 ray_direction = pixel_center - push.camera.pos + offset;
    Ray ray = Ray(push.camera.pos, NEW_RAY_START, ray_direction, infinity);

    // Cast ray
    vec4 new_color = cast_ray(ray);

    // Apply gamma correction
    new_color.rgb = pow(new_color.rgb, vec3(push.camera.gamma));

    // TODO use max_samples to divide
    if (multisample) {
        vec4 prev_col = imageLoad(output_image, UVi.xy);
        new_color = mix(prev_col, new_color, 1.0 / max(1.0, push.frame));
        // new_color = prev_col + new_color / push.max_samples;
        // if (push.frame == 0) {
        //     new_color = vec4(0);
        // }
    }

    imageStore(output_image, UVi.xy, new_color);
}
