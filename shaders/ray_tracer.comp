#version 450

// Made by following the "Ray Tracing in One Weekend Series"
//  by Peter Shirley, Trevor David Black, Steve Hollasch 
//  https://raytracing.github.io/books/RayTracingInOneWeekend.html

// Currently following "Ray Tracing The Next Week"

/*

POLICIES
========

The camera points in the negative z direction with positive y being up and positive x being right.

The render image's origin is in the top left. u direction is right and v is down.

Index 0 usually points to an empty or intentionally invalid value.

RayHit structs don't determine normals and intersection points on-hit. They 
have to have determine_rayhit called on them afterwards to have valid values.

Normals always point outwards from surfaces and are always normalized on creation.

Ray depth starts at 0 and goes up as depth increases.

Materials have something called refraction_depth. When two objects intersect and at least one of them
are translucent, their refraction_depth will be compared. Whicher object which has the lowest 
depth value will have their material represented in the intersection.
Basically it determines if a translucent object cuts into another object or not.

mtl_index and object_index refer to the an material and object in the global material list and 
object list respectively. There may be multiple object lists in which case an object_type enum
will determine which object list object_index points to.

texture_index and texture_type, similarly to object_index and object_type, point to a texture 
and specifies what kind of texture it is respectively, however texture index either points to 
a texture in an array or, if texture_type is zero, to a procedural_texture_function.

Procedural textures are single function files which takes in a vec3 position and returns a vec4 color.
These functions are written in a seperate file and inserted into this file by the preprocessor. 
The function's name should be "procedural_texture".
 

LONG TERM GOALS
===============

    - Add detail when standing still

    - Add skybox

    - Add surface textures

    - Make set theory functions possible with objects like add and subtract 
        (can see insides of objects)

    - Subfurface scattering

    - Add lighting

    - Make a real time ray tracer with triangle geometry (will be scuffed)

    - Implement meshlets for more dynamic materials and better culling (for traingles)

*/


// Invocations in the (x, y, z) dimension
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;


// CONSTANTS
// =========
const float infinity = 1. / 0.;
const double pi_d = 3.1415926535897932385;
const float pi = 3.1415926535897932385;
const float pi_half = pi / 2.;
const float pi_double = pi * 2;
const float eps = 0.00001;

// object_type enumerator
const int is_not_obj = 0;
const int is_sphere = 1;
const int is_plane = 2;

// texture_type enumerator
const int is_procedural_spatial = 0; // For point hit procedural function
const int is_procedural_flat = 1; // For uv procedural functions
const int is_sampled_texture = 2; // For uv sampling from texture buffer
const int is_no_texture = 3;

// BVH child_index enum
// const int is_BVHNode = 1;

// The program will keep track of which objects a ray is inside of to do correct calculations
//  i.e. IOR tracking
const int max_depth_inside = 8;
int inside_of_count = 0; // Keeps track of first vacant index in stack
// Holds the object_index, obejct_type and refraction_depth of and object
ivec3 inside_of[max_depth_inside];

// IORs
const float IOR_air = 1.0;
float current_IOR = IOR_air;

const vec4 default_color = vec4(0.7, 0.7, 0.9, 1);
const int max_depth = 64 * 3; // Length of rayhits to visit stack in BVH 

int refraction_bounces = 0; // Counts the number of times a ray has refracted

// Maximum number of children a BVHNode can have
const int max_children = 2; // Replaced by script preprocessor, do NOT touch this line
const int filler_const = int(mod(max_children, 2) + 2.) * 2; 

// Flags
bool flags[4];
bool use_bvh;
bool show_bvh_depth;

bool multisample;
bool sample_all_textures; // Deprecated


float random_number;

// DATATYPES
// =========
struct Camera {
    vec3 pos;
    float focal_length;
    vec3 right;
    float viewport_width;
    vec3 up;
    float viewport_height;
    vec3 forward;
    float gamma;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    // How much of the light between zero and one is reflected for each color, 
    // zero being black
    vec3 albedo; 
    // How much the reflections scatter 
    float roughness; 
    // IDK what this means, metal n stuff, 1 is metal, 0 is dielectric
    float metallic;

    // Value between 0 and 1 where 0 is fully opaque and 1 is fully transparent.
    // Values inbetween determine the energy loss per unit length. 
    // Non-opaque materials can refract.
    float opacity; 
    // Index of refraction
    float IOR;
    // In cases where a translusent object intersects other objects or contains other translusent 
    //  objects, the refraction_depth will determine which object's material will take precedence 
    //  in the intersection
    int refraction_depth;
};

// The materials stored in objects are indices to a global material array
struct Plane {
    vec3 normal;
    float d;
    int mtl_index;
    int texture_index;
    int texture_type;
    int filler1;
};

struct Sphere {
    vec3 center;
    float radius;
    int mtl_index;
    int texture_index;
    int texture_type;
    int filler1;
};

struct RayHit {
    // TODO Optimize rayhit memory consumption
    bool hit; // Whether the ray actually hit something
    bool is_initialized; // Whether values like point and normal are determined

    // Stored on-hit
    Ray ray;
    float t; // Paramater value for ray
    int object_type; // enum for what type of object was hit
    int object_index; // The index of object hit in their respective object list, provided by object_type

    // Retrieved later
    int mtl_index; // Material of the object hit
    int texture_index;
    int texture_type;
    vec3 point; // Intersection point between sphere and ray
    vec2 uv;
    vec3 normal;
    vec4 color; // Whatever color the rayhit is determined to be 
};

struct Range {
    float start; 
    float end;
};

struct AABB {
    // only xyz used, they are vec4 to fit memory allocation
    // minimum.x < maximum.x etc. should always be true, use create_AABB function to be safe
    vec4 minimum;
    vec4 maximum;
};

struct ChildIndex {
    // Small struct to add labels to child indices in a BVHNode
    int index; // Points to a child BVHNode if object_type is 0, else it points to an object 
    int object_type; // Specifies the object_type index points to. If object_type is 0, it points to
    // another BVHNode
};

// BVH should be shared across all groups, how doe? Might make compute shader to make BVH
struct BVHNode {
    // A BVHNode is an node in a n-ary tree. They are stored in a global BVH buffer. Every node 
    //  points to its parents, its own and its childrens indicies in the list. 
    //  Instead of pointing to a child node it might point to an object in specified object list
    
    // TODO: compact BVHNode struct, its a little to big.
    ChildIndex children[max_children]; // List of children, see ChildIndex
    int temp_fill[filler_const];
    AABB bbox; // Bounding box that encompasses all children 
    int child_count; // Says how many ChildIndixes actually exist and are valid
    int parent; // Index to parent in BVH list. This value is currently unused.
    int self; // Index to self in the BVH list, -1 means the node position is not finalized
    // -2 means BVHNode doesn't exist. This value is currently unused.
    int filler;
};


// BUFFERS
// =======
layout(rgba32f, set = 0, binding = 0) uniform restrict image2D output_image;

layout(set = 1, binding = 0, std430) restrict readonly buffer LODBuffer {
    int width;
    int height;
    int samples_per_pixel; // How many rays are sent per pixel
    int max_default_depth; // How many bounces is sampled, for normal rays
    int max_refraction_bounces; // How many total extra bounces can occur on refraction
} LOD;

// Materials to index
layout(set = 2, binding = 0, std430) restrict readonly buffer MaterialBuffer {
    Material data[];
} materials;

// Objects
layout(set = 2, binding = 1, std430) restrict readonly buffer SpheresBuffer {
    Sphere data[];
} spheres;

layout(set = 2, binding = 2, std430) restrict readonly buffer PlanesBuffer {
    Plane data[];
} planes;

// BVH tree in list form
layout(set = 3, binding = 0, std430) restrict readonly buffer BVH_List {
    BVHNode list[];
} BVH;

layout(push_constant, std430) restrict readonly uniform constants {
    Camera camera;
    float time;
    int flags;
    ivec2 image_offset; // How many pixels offset should the viewport origin be
    float frame;
} push;

// UTILITY FUNCTIONS
// =================

Ray empty_ray() {
    return Ray(vec3(0), vec3(0));
}

Material empty_material() {
    return Material(vec3(0), 0., 0., 1., IOR_air, 0);
}

Sphere empty_sphere() {
    return Sphere(vec3(0), 0., 0, 0, 0, 0);
}

Plane empty_plane() {
    return Plane(vec3(0), 0., 0, 0, 0, 0);
}

RayHit empty_rayhit() {
    return RayHit(false, false, empty_ray(), infinity, 0, 0, 0, 0, 0,
                  vec3(0), vec2(0), vec3(0), vec4(0));
}

ChildIndex empty_child_index() {
    return ChildIndex(0, 0);
}

// BVHNode empty_BVHNode() {
//     ChildIndex children[max_children];
//     for (int i = 0; i < max_children + filler_const / 2; i++) {
//         children[i] = empty_child_index();
//     }
//     AABB bbox = AABB(vec4(0), vec4(0));
//     return BVHNode(children, int[filler_const](0, 0), bbox, 0, 0, 0, 0);
// }

AABB create_AABB(vec3 point1, vec3 point2) {
    return AABB(vec4(min(point1, point2), 0), vec4(max(point1, point2), 0));
}

AABB sphere_AABB(Sphere sphere) {
    // Calculate AABB for a sphere
    vec3 radius_vec = vec3(sphere.radius);
    return AABB(vec4(sphere.center - radius_vec, 0), vec4(sphere.center + radius_vec, 0));
}

AABB merge_AABB(AABB box1, AABB box2) {
    // Make a new AABB tow fit two other AABBs
    AABB out_AABB;
    out_AABB.minimum = min(box1.minimum, box2.minimum);
    out_AABB.maximum = min(box1.maximum, box2.maximum);
    return out_AABB;
}

void expand_AABB(inout AABB bbox, float delta) {
    float padding = delta / 2.;
    bbox.minimum -= padding;
    bbox.maximum += padding;
}

bool intersect_AABB(AABB bbox1, AABB bbox2) {
    // Returns whether two AABB intersect
    for (int i = 0; i < 3; i++) {
        if (bbox1.minimum[i] > bbox2.maximum[i] || bbox1.maximum[i] < bbox2.minimum[i]) {
            return false;
        }
    }
    return true;
}

float atan2(float y, float x) {
    // Apparantly more stable atan function, read:
    // https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle

    bool s = (abs(x) > abs(y));
    return mix(pi / 2.0 - atan(x,y), atan(y,x), s); // Should perform as well as ternary
}

float rand(float seed) {
    return fract((seed * 23489.52364) / 0.0836);
}

float rand2(vec2 co) { 
  return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

vec3 rand_vec3(vec3 point) {
    // Creates a normalized vector in a random direction from a point 
    // I got tricked by the tutorial :(
    vec3 n = vec3(
        rand2(point.xy) - 0.5, 
        rand2(point.xz) - 0.5, 
        rand2(point.yz) - 0.5);
    return normalize(n);
}

void swap(inout float a, inout float b) {
    // Swap the values of two floats
    a = a + b;
    b = a - b;
    a = a - b;
}

bool is_close(float value1, float value2) {
    // Whether a value is within an epsilon of value2
    return (value2 + eps > value1 && value1 > value2 - eps);
}

bool near_zero(vec3 vec) {
    // Whether a vec3 is close to zero in all fields
    return (vec.x < eps && vec.y < eps && vec.z < eps);
}

bool in_range(float value, Range range) {
    // In range inclusively start and stop values
    return (range.start <= value && range.end >= value);
}

bool xin_range(float value, Range range) {
    // In range exclusively start and stop values
    return (range.start < value && range.end > value);
}

vec3 ray_at(Ray ray, float t) {
    return ray.origin + ray.direction * t;
}

void parse_flags() {
    int bit = int(pow(2, flags.length() - 1));
    int num = push.flags;
    // Loop over the i-th bit from most significant to least
    for (int i = flags.length() - 1; i >= 0; i--) {
        num -= bit;
        if (num < 0) {
            flags[i] = false;
            num += bit;
        } else {
            flags[i] = true;
        }
        bit = bit / 2;
    }

    use_bvh = flags[0];
    show_bvh_depth = flags[1];
    multisample = flags[2];
    sample_all_textures = flags[3];
}

// TEXTURE STUFF
// =============

vec2 sphere_get_uv(vec3 pos) {
    float theta = acos(-pos.y);
    float phi = atan(-pos.z, pos.x) + pi;

    vec2 uv = vec2(phi / pi_double, theta / pi);

    return uv;

}

// Preprocessor will place procedural texture definitions here
//procedural_texture_function_definition_hook

vec4 procedural_texture(vec3 pos, int function) {
    // This function will be pre processed and filled procedural texture functions.
    // For sampled textures there is a different implementation (not yet implemented)
    
    // Return white as default function
    if (function == 0) {
        return vec4(1);
    }
    
    // Preprocessor will insert procedural texture functions here
    //procedural_texture_function_call_hook

    // Also return white when function not found
    return vec4(1);
}


vec4 get_texture(RayHit rayhit) {
    if (rayhit.texture_type == is_procedural_spatial) {
        // return vec4(0.9);
        return procedural_texture(rayhit.point, rayhit.texture_index);
    }
    else if (rayhit.texture_type == is_procedural_flat) {
        return procedural_texture(vec3(rayhit.uv, 0), rayhit.texture_index);
    }
    // TODO Add sampled textures
}


// RAY-HIT FUNCTIONS
// =============

vec4 hit_skybox(Ray ray, inout RayHit rayhit) {
    // TODO: Implement skybox texture and hit detection
    return default_color;
}

void set_rayhit(inout RayHit rayhit, float t, Ray ray, int object_type, int object_index) {
    rayhit.hit = true;
    rayhit.t = t;
    rayhit.ray = ray;
    rayhit.object_type = object_type;
    rayhit.object_index = object_index;
}

bool hit_AABB(Ray ray, AABB bbox, Range range, vec3 inv_dir, bvec3 is_dir_neg) {
    // Returns true if ray hits aabb within given range
    for (int i = 0; i < 3; i++) {
        float orig = ray.origin[i]; // This is an optimazation. Source: Trust me (real)
        float t0 = ((bbox.minimum[i] - orig) * inv_dir[i]);
        float t1 = ((bbox.maximum[i] - orig) * inv_dir[i]);

        // Make sure t0 is smallest
        if (is_dir_neg[i]) {swap(t0, t1);}

        if (t0 > range.start) {range.start = t0;}
        if (t1 < range.end) {range.end = t1;}

        if (range.end <= range.start) {return false;}
    }
    return true;
}

RayHit hit_sphere(Ray ray, int sphere_index, Range t_range, inout RayHit rayhit) {

    Sphere sphere = spheres.data[sphere_index];
    // Calculate the determinant of quadratic formula
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float discriminant = half_b * half_b - a*c;

    // Early return if ray does not hit
    if (discriminant < 0.) {
        return rayhit;
    } 

    float sqrtd = sqrt(discriminant);
    float root = (-half_b - sqrtd) / a;

    // If root is within a valid t range and less than previous rayhit
    if (!in_range(root, t_range) || root > rayhit.t) {
        root = (-half_b + sqrtd) / a;
        if (!in_range(root, t_range)  || root > rayhit.t) {
            return rayhit;
        }
    }

    // Set rayhit variables
    set_rayhit(rayhit, root, ray, is_sphere, sphere_index);

    return rayhit;
}

RayHit hit_spheres(Ray ray, Range t_range, inout RayHit rayhit) {
    if (near_zero(vec3(spheres.data[0].radius))) {return rayhit;} // Early return if no spheres in scene
    // Uses global scope sphere array to bypass function parameter limitations
    for (int i = 0; i < spheres.data.length(); ++i) {
        hit_sphere(ray, i, t_range, rayhit);
    }
    return rayhit;
}

RayHit hit_plane(Ray ray, int plane_index, Range t_range, inout RayHit rayhit) {
    
    Plane plane = planes.data[plane_index];

    float intersection_t = ((plane.d - dot(ray.origin, plane.normal)) /
                            dot(plane.normal, ray.direction));

    // Early return if plane is paralell, even if the ray is contained in the plane
    if (isnan(intersection_t) || (isinf(intersection_t))) {
        return rayhit;
    }

    // Early return if t is not in range or further away than previous t
    if (!in_range(intersection_t, t_range) || intersection_t > rayhit.t) {
        return rayhit;
    }

    // Set rayhit variables
    set_rayhit(rayhit, intersection_t, ray, is_plane, plane_index);

    return rayhit;
}

RayHit hit_planes(Ray ray, Range t_range, inout RayHit rayhit) {
    if (near_zero(planes.data[0].normal)) {return rayhit;} // Early return if no planes in scene
    // Uses global scope planes array to bypass function parameter limitations
    for (int i = 0; i < planes.data.length(); ++i) {
        hit_plane(ray, i, t_range, rayhit);
    }
    return rayhit;
}

RayHit hit_object(Ray ray, Range range, inout RayHit rayhit, int object_index, int object_type) {
    // Chooses the appropriate hit_ function for given object_type
    if (object_type == is_sphere) {
        return hit_sphere(ray, object_index, range, rayhit);
    }
}

RayHit determine_rayhit(inout RayHit rayhit) {
    // Resolves intersextion point, normal and other information from rayhit 
    rayhit.point = ray_at(rayhit.ray, rayhit.t);

    // Procedure for hitting sphere
    if (rayhit.object_type == is_sphere) {
        Sphere sphere = spheres.data[rayhit.object_index];
        rayhit.mtl_index = sphere.mtl_index;
        rayhit.texture_index = sphere.texture_index;
        rayhit.texture_type = sphere.texture_type;
        rayhit.normal = (rayhit.point - sphere.center) / sphere.radius;
        rayhit.color = vec4(materials.data[rayhit.mtl_index].albedo, 1);
        rayhit.uv = sphere_get_uv(rayhit.point);

    // Procedure for hitting plane
    } else if (rayhit.object_type == is_plane) {
        Plane plane = planes.data[rayhit.object_index];
        rayhit.mtl_index = plane.mtl_index;
        rayhit.texture_index = plane.texture_index;
        rayhit.texture_type = plane.texture_type;
        rayhit.normal = plane.normal;
        rayhit.color = vec4(materials.data[rayhit.mtl_index].albedo, 1);
    }

    rayhit.is_initialized = true;
    return rayhit;
}

RayHit check_ray_hit(Ray ray, Range range) {
    
    RayHit rayhit = empty_rayhit();
    hit_spheres(ray, range, rayhit);
    
    hit_planes(ray, range, rayhit);

    // TODO ADD intersection with skybox, would still count as not hit
    if (!rayhit.hit) {
        rayhit.color = default_color;
    }

    return rayhit;
}


RayHit check_ray_hit_BVH(Ray ray, Range range) {
    // Like check_ray_hit but it checks against a BVH tree instead of each object_list individually
    RayHit rayhit = empty_rayhit();

    // Stack of indices of nodes yet to traverse
    // NOTE: might need to be bigger for larger scenes and/or with higher order trees
    int to_visit[max_depth];
    // Index to top of the stack, points to vacant spot ABOVE the stack
    int to_visit_i = 0;

    // Index to current node being processed
    int current_index = 0;

    bool small_break = false;

    vec3 new_point;

    // Pre-compute values for hit detection
    vec3 inv_direction = vec3(1. / ray.direction.x, 1. / ray.direction.y, 1. / ray.direction.z);
    bvec3 dir_is_negative = bvec3(inv_direction.x < 0., inv_direction.y < 0., inv_direction.z < 0.);

    int hit_check_count = 0;
    while (true) {
        if (current_index >= max_depth) {
            break;
        }
        BVHNode node = BVH.list[current_index];

        hit_check_count++;

        // If ray already hit something, ignore aabbs which are not in the same octant as the 
        //  ray origin relative to the intersection point, barely any performance impact
        if (rayhit.hit) {
            new_point = ray.origin + ray.direction * rayhit.t;
            vec4 new_min = node.bbox.minimum;
            vec4 new_max = node.bbox.maximum;

            // small_break = (ray.direction.x > 0.) ? (new_point.x < node.bbox.minimum.x) : 
            // (new_point.x > node.bbox.maximum.x) ||
            //               (ray.direction.y > 0.) ? (new_point.y < node.bbox.minimum.y) : 
            //               (new_point.y > node.bbox.maximum.y) || 
            //               (ray.direction.z > 0.) ? (new_point.z < node.bbox.minimum.z) : 
            //               (new_point.z > node.bbox.maximum.z);

            small_break = (ray.direction.x > 0.) ? (new_point.x < new_min.x) :
             (new_point.x > new_max.x);
            if (!small_break) {
                small_break = (ray.direction.y > 0.) ? (new_point.y < new_min.y) :
                 (new_point.y > new_max.y);

                if (!small_break) {
                    small_break = (ray.direction.z > 0.) ? (new_point.z < new_min.z) :
                     (new_point.z > new_max.z);
                }
            }
        }

        if (!small_break) {
        if (hit_AABB(ray, node.bbox, range, inv_direction, dir_is_negative)) {
            // Loop over child indices to add them to stack or do hit check
            for (int i = node.child_count; i > 0; i--) {
                ChildIndex tochild = node.children[i - 1];
                // If children[i].index points to inner node, add it to to_visit
                if (tochild.object_type == is_not_obj) {
                    to_visit[to_visit_i++] = tochild.index;
                } 
                // children[i].index points to object_index, do a hit test
                else {
                    hit_object(ray, range, rayhit, tochild.index, tochild.object_type);
                    hit_check_count++;
                    
                }
            }
        }
        }
        small_break = false;
        // Break if no more nodes to visit, else go to next node in list
        if (to_visit_i == 0) {break;}
        current_index = to_visit[--to_visit_i];
    }
    
    hit_planes(ray, range, rayhit);

    // TODO ADD intersection with skybox, would still count as not hit
    if (!rayhit.hit) {
        rayhit.color = hit_skybox(ray, rayhit);
    }

    if (show_bvh_depth) {
        // TODO Improve visual accuracy 
        float a = float(hit_check_count) / float(BVH.list.length() * 2);
        float b = pow(a, 3.5);
        rayhit.color = vec4(a,b,1,0);
    }

    return rayhit;
}

// RAY-BOUNCE FUNCTIONS
// ====================
Ray reflect_ray(Ray ray_in, RayHit rayhit) {
    // Returns a new reflected ray based on ray_in and rayhit
    vec3 reflected_dir = reflect(ray_in.direction, rayhit.normal) * materials.data[rayhit.mtl_index].metallic;
    vec3 dir_offset = rand_vec3(rayhit.point) * (1. - materials.data[rayhit.mtl_index].metallic);

    Ray ray_out = Ray(rayhit.point, reflected_dir + dir_offset);
    
    // Reflects ray if it points into the object
    if (dot(ray_out.direction, rayhit.normal) < 0.) {
        ray_out.direction = reflect(ray_out.direction, rayhit.normal);
    }

    return ray_out;
}

Ray refract_ray(Ray ray_in, inout RayHit rayhit) {
    // Returns a refracted or reflected ray based on ray_in and rayhit
    Ray ray_out;
    ray_out.origin = rayhit.point;

    // Whether object is inside the current object
    bool is_inside = bool(dot(rayhit.normal, ray_in.direction) > 0.);
    float eta_in = current_IOR;

    // if (inside_of_count == 1) {}

    float eta_out = (is_inside) ? IOR_air : materials.data[rayhit.mtl_index].IOR;

    float eta;
    eta = eta_in / eta_out;

    // TODO: Finish refraction depth thingy, glass inside glass renders wrongly
    // for (int i = 0; i < inside_of_count; i++) {}

    vec3 normalized_direction = normalize(ray_in.direction);
    vec3 normal = (is_inside) ? -rayhit.normal : rayhit.normal;

    // Calculate whether angle is shallow enough to disallow refraction
    float cos_theta = min(dot(-normalized_direction, normal), 1.);
    float sin_theta = sqrt(1. - cos_theta * cos_theta);
    bool cannot_refract = eta * sin_theta > 1.;

    // // Check for internal reflection
    if (cannot_refract) {
        ray_out.direction = reflect(normalized_direction, normal);
        return ray_out;
    } 

    // Schlick's approximation for reflectivety
    float r0 = (1. - eta) / (1. + eta);
    r0 = r0 * r0;
    float reflect_chance = r0 + (1. - r0) * pow(1. - cos_theta, 5.);
    
    // Check for external reflection, TODO can add reflexivety for translucent materials
    if (reflect_chance > rand2(vec2(cos_theta, normal.x))) {
        ray_out.direction = reflect(normalized_direction, normal);
        return ray_out;
    }

    current_IOR = eta_out;

    // If ray was inside and went out, remove from inside_of list
    if (is_inside) {
        inside_of[inside_of_count--] = ivec3(0,0,0);
    } else {
        // If ray was outside and refracted, add to inside_of list
        inside_of[inside_of_count++] = ivec3(rayhit.object_index, rayhit.object_type, 
        materials.data[rayhit.mtl_index].refraction_depth);
    }

    // Add extra available bounces when ray refracts
    if (refraction_bounces < LOD.max_refraction_bounces - 1) {refraction_bounces++;}

    ray_out.direction = refract(normalized_direction, normal, eta);
    return ray_out;
}

Ray scatter_ray(Ray ray_in, RayHit rayhit) {
    // TODO Change the way rays are created based on roughness, less/ more scatter
    // Returns a scattered ray based on ray_in and rayhit
    vec3 ray_dir = rand_vec3(rayhit.point + rayhit.ray.direction) + rayhit.normal;

    // If created ray pointed in opposite direction of normal
    ray_dir = near_zero(ray_dir) ? rayhit.normal : ray_dir;

    // Make sure reflected ray points in the same way as normal
    ray_dir = dot(ray_dir, rayhit.normal) < 0. ? ray_dir * -1.0 : ray_dir;

    return Ray(rayhit.point, ray_dir);;
}

Ray bounce_ray(Ray ray_in, RayHit rayhit) {
    // Creates a new ray based material properties from the previous rayhit

    // TODO Make more sophisticated function choosing
    if (materials.data[rayhit.mtl_index].opacity < 1.) {
        return refract_ray(ray_in, rayhit);
    }

    if (materials.data[rayhit.mtl_index].metallic > 0.) {
        return reflect_ray(ray_in, rayhit);
    }

    return scatter_ray(ray_in, rayhit);
}

// MAIN FUNCTIONS
// ==============
vec4 cast_ray(Ray ray, Range range) {
    // Casts a ray with bounces and returns the color of the ray

    // Turns out computing colors in the same loop was faster, TODO maybe reconsider
    // Rayhit's color should determined in reverse order, so we to store them for later
    // RayHit rayhits[64];

    // Calculate rayhits
    Ray new_ray = ray;
    RayHit rayhit;
    refraction_bounces = 0;
    vec4 new_color = vec4(1);
    vec4 tex_col = vec4(1);

    // for (int i = 0;i < LOD.max_default_depth; i++) {
    for (int i = 0;i < LOD.max_default_depth + refraction_bounces; i++) {
        if (use_bvh) {
            rayhit = check_ray_hit_BVH(new_ray, range);

            // Send one ray, skip bouncing
            if (show_bvh_depth) {
                new_color = rayhit.color;
                break;
            }
        } else {
            rayhit = check_ray_hit(new_ray, range);
        }
        
        // Early break if no hit
        if (!rayhit.hit) {
            // Adds sky color as the last rayhit when miss
            new_color *= rayhit.color;
            break;
        }

        determine_rayhit(rayhit);

        // Get texture color
        tex_col = rayhit.texture_type == 0 ? get_texture(rayhit) : vec4(1);

        // TODO: implement attenuation based on incident and exiting angles
        new_color *= rayhit.color * tex_col;

        new_ray = bounce_ray(new_ray, rayhit);
    } 

    return new_color;
}


// The code we want to execute in each invocation
void main() {

    // VARIABLE DEFINITIONS
    // ====================

    const float width = float(LOD.width);
    const float height = float(LOD.height);

    // Calculate the vectors across the horizontal and down the vertical viewport edges.
    const vec3 viewport_u = push.camera.right * push.camera.viewport_width;
    const vec3 viewport_v = -push.camera.up * push.camera.viewport_height;

    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
    const vec3 pixel_delta_u = viewport_u / width;
    const vec3 pixel_delta_v = viewport_v / height;

    // Calculate the location of the upper left pixel.
    const vec3 viewport_upper_left = push.camera.pos - push.camera.forward * push.camera.focal_length -
                                     (viewport_u + viewport_v) / 2.;

    const vec3 pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);

    // gl_GlobalInvocationID uniquely identifies this invocation across all work groups
    // const uvec3 UVu = gl_GlobalInvocationID + uvec3(push.image_offset, 0);
    const ivec3 UVi = ivec3(gl_GlobalInvocationID) + ivec3(push.image_offset, 0);
    const vec3 UV = vec3(UVi);

    vec3 pixel_center = pixel00_loc + (UV.x * pixel_delta_u) + (UV.y * pixel_delta_v);

    // Initialize render flags
    parse_flags();

    // CODE
    // ====

    // Create ray with offset
    vec3 offset = (pixel_delta_u / 2) * (rand(float(push.time)) - 1.) + 
                  (pixel_delta_v / 2) * (rand(float(push.time)) - 1.);
    vec3 ray_direction = pixel_center - push.camera.pos + offset;
    Ray ray = Ray(push.camera.pos, ray_direction);

    // Cast ray
    vec4 new_color = cast_ray(ray, Range(0.001, infinity));

    // Apply gamma correction
    new_color.rgb = pow(new_color.rgb, vec3(push.camera.gamma));

    if (multisample) {
        vec4 prev_col = imageLoad(output_image, UVi.xy);
        new_color = mix(prev_col, new_color, 1.0 / max(1.0, push.frame));
    }

    imageStore(output_image, UVi.xy, new_color);
}


