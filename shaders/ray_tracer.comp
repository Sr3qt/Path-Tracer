#version 450
#extension GL_EXT_nonuniform_qualifier : require

// Based on the great tutorial "Ray Tracing in One Weekend Series"
//  by Peter Shirley, Trevor David Black, Steve Hollasch
//  https://raytracing.github.io/books/RayTracingInOneWeekend.html

// Noise functions taken from Ray Tracer Demo godot project by HK-SAO
// https://godotengine.org/asset-library/asset/1550

/*

List of features:
    - Supported objects:
        3D simples:
            - TODO 3: Add rounding for 3d simples
            - spheres

        2D simples:
            - triangles

        - planes
        - meshes (Collection of primitives)

    - instancing of objects (spheres so far)

    - Material types:
        -diffuse
        -metallic
        -transparent/glass

    - Multisampling

    - Procedural and sampled textures

    - Nested Dielectrics


POLICIES
========

The camera points in the negative z direction with positive y being up and positive x being right.

The render image's origin is in the top left. u direction is right and v is down.

The first index of the materials array is reserved for a builtin white matt material.

RayHit structs don't determine normals and intersection points on-hit. They
have to have determine_rayhit called on them afterwards to have valid values.

Normals always point outwards from surfaces and are always normalized on creation.
Ray direction is also normalized on creation.

Ray depth is the number of bounces it has done. It starts at 0 and goes up as the ray bounces.

Materials have something called dielectric_priority. A higher number takes priority.
See Refraction Tracking in PRE PROCESSOR STUFF

mtl_index and object_index refer to a material and an object in the global material list and
object list respectively. There are multiple object lists object_index can point to, which
the object_type enum will determine. The object_type and object_index is
encoded in an object_id. object_id is an unique identifier for every object.
These object_ids are stored in an array and an index into that array is called an object_id_index.

texture_index and texture_type, similarly to object_index and object_type, point to a texture
and specifies what kind of texture it is respectively. Similarly to object_index and object_type,
texture_index and texture_type is consolidated into a texture_id. texture_type can have the flag
is_sampled which means the texture is sampled. If not then the texture is procedurally generated.

Procedural textures are single function files which takes in a vec3 position and returns a vec4 color.
These functions are written in a seperate file and inserted into this file by the preprocessor.
The function's name should be "procedural_texture".

Meshes that are instantiated will have a "mesh-socket" BVHNode as its parent in the global BVH tree.
This node is identifiable by having only one child node and having its transform index be positive.
The transform index should apply to all nodes and objects under the mesh-socket.


LONG TERM GOALS
===============

    - Add detail when standing still -- DONE --

    - Add skybox

    - Add surface textures -- ALMOST --

    - Make set theory functions possible with objects like add and subtract
        (can see insides of objects)

    - Subfurface scattering

    - Add lighting -- BASIC --

    - Make a real time ray tracer with triangle geometry (will be scuffed) -- ALMOST --

    - Implement meshlets for more dynamic materials and better culling (for traingles)

    - Simulate glass of beer

*/


// Invocations in the (x, y, z) dimension
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// PRE PROCESSOR STUFF

/*
// Fun fact, I happened to implement Nested Dielectrics not knowing what it was.
// However, I still prefer to call it refraction tracking.
Refraction tracking is the practice of answering the question,
"What is the material in the intersection between two objects?".
Refraction tracking solves this by assigning a dielectric priority to all materials,
and choosing the material with the highest priority when leaving an object inside of another.

This should, in theory, come with the abiltiy to cut objects with another object that has
air as its material. It also allows for composite glass objects; Rays will travel through multiple
transparent objects with the same material as if it was one homogenous mass,
although at a higher ray depth cost (It might not get out if max_default_depth is low).

Enabling any of the options below might have a small performance impact
Diferent modes:
    - 0 Disabled nested dielectrics and disabled IoR tracking,
        dielectric refractions will assume IOR_air for ior_out
    - 1 Disabled nested dielectrics and enabled IoR tracking,
        dielectric refractions will assume previous entered material for ior_in
    - 2 Enable nested dielectrics, priority will be assumed to be first entered having lowest priority.
    - 3 Enable nested dielectrics and dielectric priority, will use dielectric priority of material.
*/
#define use_refraction_tracking 3

// IN sphere_scene_3 the ground is first way to bright then it darkens drastically
// TODO 1: Make it so that the color and intensity doesn't change much.
// Probably need to look at roughness new ray creation and attenuation. Need to attenuate based on roughness
// TODO 2: Make toggle in editor for emmission rendering.
// Emissive materials
#define USE_EMISSION 0

// Slower on primary rays but faster on secondary
#define use_early_t_break 0


// Whether to check for certain conditions. Probably has some performance impact.
// Will write to the result of conditions to main image buffer dpending on given render modes.
// TODO 2: Implement IS_DEBUG for more perf when it is off
// #define IS_DEBUG 1


// TODO 3: Add option to give max ray length for first rays and secondary rays for performance

// CONSTANTS
// =========
const int int_limit = 2147483647;
const int uint_limit = 4294967295;
const int neg_int_limit = -2147483648;
const int all_ones = -1;
const float infinity = 1. / 0.;
const double pi_d = 3.1415926535897932385;
const float pi = 3.1415926535897932385;
const float pi_half = pi / 2.;
const float pi_double = pi * 2;
const float eps = 1e-6;

// Used by offset_ray function
const float origin = 1.0 / 32.0;
const float float_scale = 1.0 / 65536.0;
const float int_scale = 256.0;

// object_type enumerator
// From now on, the object_type is encoded as the first byte of an object_id
const int is_not_obj = 0;
const int is_sphere = 1;
const int is_plane = 2;
const int is_triangle = 3;

// texture_type enumerator
const int is_sampled = 1;
const int is_spatial = 2;

const int is_procedural_flat = 0; // For uv procedural functions
const int is_procedural_spatial = 2; // For point hit procedural function
const int is_sampled_texture = 1; // For uv sampling from texture buffer
const int is_no_texture = 4;

const int MAX_TEXTURE_COUNT = 512;

// Keeps values of inside_of neatly organized
struct InsideOf {
    int material_index;
    int dielectric_priority;
};

// IORs
const float IOR_air = 1.0;
#if use_refraction_tracking
float current_IOR = IOR_air;
int current_material = -1;
#endif

// This is the maximum amount of overlapping geometry that will be considered
// for nested dielectrics.
const int max_overlapping_objects = 8;

// Keeps track of first vacant index in stack
int inside_of_count = 0;

#define USE_NEW_REFRACTION_TRACKING 1
#if USE_NEW_REFRACTION_TRACKING
InsideOf empty_inside() {
    return InsideOf(-1, neg_int_limit);
}
#else
InsideOf empty_inside() {
    return InsideOf(0, neg_int_limit);
}
#endif

// Holds an array of material_index and dielectric_priority
InsideOf inside_of[max_overlapping_objects] = InsideOf[](
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside(),
    empty_inside()
);
// TODO 3: Add support for cpu to send InsideOf buffer based on camera position

#if !USE_EMISSION
const vec4 default_color = vec4(0.7, 0.7, 0.9, 1);
#endif

#if USE_EMISSION
const vec4 default_color = vec4(0);
bool is_emissive = false;
#endif

const int max_bvh_depth = 64 * 16; // Length of rayhits to visit stack in BVH
int refraction_bounces = 0; // Counts the number of times a ray has refracted

// Maximum number of inner nodes a BVHNode can have
const int order = 2; // Replaced by script preprocessor, do NOT touch this line

int current_transform_index = -1;
bool ignore_attenuation = false;

// Flags
const int flag_size = 31;
const int starting_bit = int(pow(2, flag_size - 1));
bool flags[flag_size];

bool use_bvh;
bool show_node_count;
bool show_object_count;

bool multisample;

// #if IS_DEBUG

// Render flags
const int RENDER_MODE_DEFAULT = 0;
const int RENDER_MODE_BVH_VIEW = 1;
const int RENDER_MODE_NORMAL_VIEW = 2;
bool show_bvh_view;
bool show_normal_view;

vec4 debug_color = vec4(-1);
vec4 render_mode_color = vec4(-1);
bool render_mode_is_single_sample = false;

int node_hit_count = 0;
int object_hit_count = 0;

#define debug_black debug_color = vec4(0)
#define debug_red debug_color = vec4(1, 0, 0, 1)
// #endif

int previous_object = -1;

// Random
// Code snippets taken from Ray tracer demo by HK-SHAO
struct Random {
    float seed;
    float value;
};

Random random = Random(42, 0);

// DATATYPES
// =========
struct Camera {
    vec3 pos;
    float focal_length;
    vec3 right;
    float viewport_width;
    vec3 up;
    float viewport_height;
    vec3 forward;
    float gamma;
};

struct Ray {
    vec3 origin;
    float start;
    vec3 direction;
    float end;
};

struct Material {
    // How much of the light between zero and one is reflected for each color,
    // zero being black
    vec3 albedo;
    // How much the reflections scatter
    float roughness;
    // IDK what this means, metal n stuff, 1 is metal, 0 is dielectric
    float metallic;

    // Value between 0 and 1 where 0 is fully opaque and 1 is fully transparent.
    // Values inbetween determine the energy loss per unit length.
    // Non-opaque materials can refract.
    float opacity;
    float reflectivity;
    float IOR;
    // In cases where a translusent object intersects other objects or contains other translusent
    //  objects, the dielectric_priority will determine which object's material will take precedence
    //  in the intersection
    int dielectric_priority;
    bool is_emissive;
    int temp2;
    int temp3;
    int temp4;
    int temp11;
    int temp21;
    int temp31;
};

// TODO 1: Move properties to its own array and make global indices that point to object_ids

// The materials stored in objects are indices to a global material array
struct Plane {
    vec3 normal;
    float d;
    int mtl_index;
    uint texture_id;
    int filler0;
    int filler1;
};

struct Sphere {
    vec3 center;
    float radius;
    int mtl_index;
    uint texture_id;
    int filler0;
    int filler1;
};

struct Triangle {
    // TODO 3: SO MUCH SPACE OPTIMIZATION
    vec3 point1;
    float filler1;
    vec3 point2;
    float filler2;
    vec3 point3;
    float filler3;
    vec3 normal;
    float filler4;

    int mtl_index;
    uint texture_id;
    int filler0;
    int filler5;
};

struct RayHit {
    // Stored on-hit
    bool hit;
    int object_id;
    int transform_index;

    // Retrieved later
    vec2 uv;
    vec3 point;
    int mtl_index;
    vec3 normal;
    uint texture_id;
    vec4 color;
};

struct AABB {
    // only xyz is used, they are vec4 to fit memory allocation
    // minimum.x < maximum.x etc. should always be true.
    // The w value is unused by the aabb, so it can be filled with whatever is useful
    vec4 minimum;
    vec4 maximum;
};

struct Transform {
    mat4 matrix;
};

// node_index and size are hidden inside the aabb struct
#define NODE_node_id floatBitsToInt(node.bbox.minimum.w)
#define NODE_node_transform floatBitsToInt(node.bbox.maximum.w)
struct BVHNode {
    // NOTE: Remember that AABB stores FLOATS, not ints
    AABB bbox;
};


// BUFFERS
// =======
layout(rgba32f, set = 0, binding = 0) uniform restrict image2D output_image;

// SET 1 was deprecated.

// Materials
layout(set = 2, binding = 0, std430) restrict readonly buffer MaterialBuffer {
    Material data[];
} materials;

// Objects
layout(set = 2, binding = 1, std430) restrict readonly buffer SpheresBuffer {
    Sphere data[];
} spheres;

layout(set = 2, binding = 2, std430) restrict readonly buffer PlanesBuffer {
    Plane data[];
} planes;

layout(set = 2, binding = 3, std430) restrict readonly buffer TrainglesBuffer {
    Triangle data[];
} triangles;

layout(set = 3, binding = 0, std430) restrict readonly buffer BVH_List {
    BVHNode list[];
} BVH;

layout(set = 3, binding = 1, std430) restrict readonly buffer Object_ID {
    int list[];
} object_ids;

// TODO 2: Make material_index buffer similar to object id

layout(set = 4, binding = 0, std430) restrict readonly buffer TriangleVertex {
    float data[];
} triangle_vertices;

layout(set = 4, binding = 1, std430) restrict readonly buffer TriangleUV {
    float data[];
} triangle_uvs;

layout(set = 4, binding = 2, std430) restrict readonly buffer TriangleIndex {
    float data[];
} triangle_indices;

layout(set = 5, binding = 0) uniform sampler2D Textures[MAX_TEXTURE_COUNT];

// TODO 2: Make buffer for both normal and inverse transforms
// transforms currently contains global-to-mesh-space transforms
layout(set = 6, binding = 0, std430) restrict readonly buffer Transforms {
    Transform data[];
} transforms;

layout(push_constant, std430) restrict readonly uniform constants {
    Camera camera;
    int flags;
    int render_mode;
    int filler1;
    int filler2;
    int filler3;
    int image_offset_x; // How many pixels offset should the viewport origin be
    int image_offset_y;
    int node_count_threshold;
    int object_count_threshold;
    int width;
    int height;
    int max_default_depth;
    int max_refraction_bounces;
    float time;
    float frame;
    float max_samples;
} push;

// UTILITY FUNCTIONS
// =================

RayHit empty_rayhit() {
    return RayHit(false, 0, -1, vec2(0), vec3(0), 0, vec3(0), 0, vec4(0));
}

// Creates a new ray based on given origin and direction. Normalizes direction.
Ray new_ray(vec3 origin, vec3 direction) {
    return Ray(origin, 0.0, normalize(direction), infinity);
}

float atan2(float y, float x) {
    // Apparantly more stable atan function, read:
    // https://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle

    bool s = (abs(x) > abs(y));
    return mix(pi / 2.0 - atan(x,y), atan(y,x), s); // Should perform as well as ternary
}

float reflectance(float eta, float cos_theta) {
    // Schlick's approximation for reflectivety
    float r0 = (1. - eta) / (1. + eta);
    r0 = r0 * r0;
    return r0 + (1. - r0) * pow(1. - cos_theta, 5.);
}

// Random functions
float rand(float seed) {
    return fract((seed * 23489.52364) / 0.0836);
}

float noise(inout Random r) {
    // Also taken from Ray Tracer Demo by HK-SHAO
    r.value = fract(sin(r.seed++) * 43758.5453123);
    return r.value;
}

// Taken from https://www.shadertoy.com/view/XlGcRh by Mark Jarzynski and Marc Olano.
// Which in turn is taken from https://www.pcg-random.org/
float pcg(inout Random r) {
	uint state = (floatBitsToUint(r.seed++)) * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    r.value = ((word >> 22u) ^ word) / 4294967295.0;
	return r.value;
}

float rand2(vec2 co) {
  return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

vec3 random_point_on_sphere() {
    // Consistently faster than other methods by a few dozen microseconds in testing:
    //  -35ms +-15ms / 300 frames
    float theta1 = pcg(random) * pi_double;
    float theta2 = acos(2 * pcg(random) - 1);
    // TODO 2: try other ways to calculate point
    // float cos_theta2 = 2 * pcg(random) - 1;
    vec3 point = vec3(cos(theta1) * sin(theta2), cos(theta2), sin(theta1) * sin(theta2));

    return point;

}

float hash(vec3 x) {
    // Also taken from Ray Tracer Demo by HK-SHAO
    uvec3 p = floatBitsToUint(x);
    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));
    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));
    uint n = h32 ^ (h32 >> 16U);
    return float(n) * (1.0 / float(0x7fffffff));
}

void swap(inout float a, inout float b) {
    // Swap the values of two floats
    a = a + b;
    b = a - b;
    a = a - b;
}

bool is_close(float value1, float value2) {
    // TODO 1: COnsider implementing this algorithm:
    // https://stackoverflow.com/questions/4915462/how-should-i-do-floating-point-comparison
    // Whether a value is within an epsilon of value2
    return (value2 + eps > value1 && value1 > value2 - eps);
}

bool near_zero(vec3 vec) {
    // Whether a vec3 is close to zero in all fields
    return (abs(vec.x) < eps && abs(vec.y) < eps && abs(vec.z) < eps);
}

bool near_zero(float f) {
    return (abs(f) < eps);
}

vec3 offset_ray(const vec3 point, const vec3 normal) {
    // Calculates a new point for ray intersection, which stops self intersection
    // Implementation of algorithm in Ray Tracing Gems chapter 6.2.2.4
    ivec3 offset = ivec3(normal * int_scale);
    vec3 point_offset = vec3(
        intBitsToFloat(floatBitsToInt(point.x) + ((point.x < 0) ? -offset.x : offset.x)),
        intBitsToFloat(floatBitsToInt(point.y) + ((point.y < 0) ? -offset.y : offset.y)),
        intBitsToFloat(floatBitsToInt(point.z) + ((point.z < 0) ? -offset.z : offset.z))
    );
    return vec3(
        abs(point.x) < origin ? point.x + float_scale * normal.x : point_offset.x,
        abs(point.y) < origin ? point.y + float_scale * normal.y : point_offset.y,
        abs(point.z) < origin ? point.z + float_scale * normal.z : point_offset.z
    );
}

bool in_range(float value, Ray ray) {
    // Is value in range inclusively start and stop values
    return (ray.start <= value && ray.end >= value);
}

bool xin_range(float value, Ray ray) {
    // Is value in range exclusively start and stop values
    return (ray.start < value && ray.end > value);
}

vec3 ray_at(Ray ray) {
    return ray.origin + ray.direction * ray.end;
}

vec3 ray_at(Ray ray, float t) {
    return ray.origin + ray.direction * t;
}

void parse_flags() {
    int bit = starting_bit;
    int num = push.flags;
    // Loop over the i-th bit from most significant to least
    for (int i = flag_size - 1; i >= 0; i--) {
        num -= bit;
        if (num < 0) {
            flags[i] = false;
            num += bit;
        } else {
            flags[i] = true;
        }
        bit = bit >> 1;
    }

    use_bvh = flags[0];
    multisample = flags[1];
    show_node_count = flags[2];
    show_object_count = flags[3];

    show_bvh_view = push.render_mode == RENDER_MODE_BVH_VIEW;
    show_normal_view = push.render_mode == RENDER_MODE_NORMAL_VIEW;
    // Needs to be updated when new render modes appear
    render_mode_is_single_sample = show_bvh_view || show_normal_view;
}

int get_object_type(int object_id) {
    return bitfieldExtract(object_id, 24, 8);
}

int get_object_index(int object_id) {
    return bitfieldExtract(object_id, 0, 24);
}

int get_node_index(int node_id) {
    return bitfieldExtract(node_id, 0, 24);
}

int get_node_size(int node_id) {
    return abs(bitfieldExtract(node_id, 24, 8));
}

uint get_texture_type(uint texture_id) {
    return bitfieldExtract(texture_id, 30, 2);
}

uint get_texture_index(uint texture_id) {
    return bitfieldExtract(texture_id, 0, 30);
}


// TEXTURE STUFF
// =============

vec2 sphere_get_uv(vec3 pos) {
    float theta = acos(pos.y);
    float phi = atan(-pos.z, pos.x) + pi;

    vec2 uv = vec2(phi / pi_double, theta / pi);

    return uv;
}

// Preprocessor will place procedural function definitions here
//procedural_texture_function_definition_hook

vec4 procedural_texture(vec3 pos, uint function) {
    // This function will be pre processed and filled procedural texture functions.
    // For sampled textures there is a different implementation (not yet implemented)

    // Return white as default function
    if (function == 0) {
        return vec4(1);
    }

    // Preprocessor will insert procedural texture functions here
    //procedural_texture_function_call_hook

    // Return black when function not found
    return vec4(0);
}


vec4 get_texture(RayHit rayhit) {
    uint texture_type = get_texture_type(rayhit.texture_id);
    uint texture_index = get_texture_index(rayhit.texture_id);
    vec3 sampled_point = (texture_type & is_spatial) > 0 ? rayhit.point : vec3(rayhit.uv, 0);

    if ((texture_type & is_sampled) > 0) {
        return texture(nonuniformEXT(Textures[texture_index]), rayhit.uv);
    }

    return procedural_texture(sampled_point, texture_index);
}


// RAY-HIT FUNCTIONS
// =============

vec4 hit_skybox(Ray ray, inout RayHit rayhit) {
    // TODO 2: Implement skybox texture and hit detection
    return default_color;
}

float hit_AABB(Ray ray, AABB bbox, vec3 inv_dir, bvec3 is_dir_neg) {
    // I think I got this implementation from stackoverflow, but I forgot where from
    node_hit_count++;
    // Returns true if ray hits aabb within given range
    for (int i = 0; i < 3; i++) {
        float t0 = ((bbox.minimum[i] - ray.origin[i]) * inv_dir[i]);
        float t1 = ((bbox.maximum[i] - ray.origin[i]) * inv_dir[i]);

        // Make sure t0 is smallest
        if (is_dir_neg[i]) {swap(t0, t1);}

        if (t0 > ray.start) {ray.start = t0;}
        if (t1 < ray.end) {ray.end = t1;}

        if (ray.end <= ray.start) {return -1.0;}
    }
    // But if ray origin is inside the box shouldn't ray.start be negative?
    return ray.start; // t value of ray intersecting the bounding box
    // return (ray.start > 0.0) ? ray.start : ray.end; // t value of ray intersecting the bounding box
}

RayHit hit_sphere(inout Ray ray, int object_id, inout RayHit rayhit) {

    Sphere sphere = spheres.data[get_object_index(object_id)];
    // Calculate the determinant of quadratic formula
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float discriminant = half_b * half_b - a*c;

    // Early return if ray does not hit
    if (discriminant < 0.) {
        return rayhit;
    }

    // OPTIMIZATION ?
    // float sqrtd = (near_zero(discriminant)) ? 0 : sqrt(discriminant);
    float sqrtd = sqrt(discriminant);
    float root = (-half_b - sqrtd) / a;

    // If root is within a valid t range and less than previous rayhit
    if (!in_range(root, ray)) {
        root = (-half_b + sqrtd) / a;
        if (!in_range(root, ray)) {
            return rayhit;
        }
    }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    rayhit.transform_index = current_transform_index;
    ray.end = root;

    return rayhit;
}

vec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )
{
    vec3 oc = ro - ce;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - ra*ra;
    float h = b*b - c;
    if( h<0.0 ) return vec2(-1.0); // no intersection
    h = sqrt( h );
    return vec2( -b-h, -b+h );
}

// sphere of size ra centered at point ce
vec2 sphIntersectPrec( in vec3 ro, in vec3 rd, in vec3 ce, float ra )
{
    vec3 oc = ro - ce;
    float b = dot( oc, rd );
    vec3 qc = oc - b*rd;
    float h = ra*ra - dot( qc, qc );
    if( h<0.0 ) return vec2(-1.0); // no intersection
    h = sqrt( h );
    return vec2( -b-h, -b+h );
}

RayHit hit_sphere_iquilez(inout Ray ray, int object_id, inout RayHit rayhit) {

    Sphere sphere = spheres.data[get_object_index(object_id)];

    float root;
    vec2 t = sphIntersectPrec(ray.origin,(ray.direction), sphere.center, sphere.radius);
    // if (!in_range(t.y, ray)) {return rayhit;} // ray does NOT intersect the sphere
    // else if (!in_range(t.x, ray)) {root = t.y;} // ro  inside the sphere, t.y is intersection distance
    // else               {root = t.x;} // ro outside the sphere, t.x is intersection distance

    if (in_range(t.x, ray)) {
        root = t.x;
    } else if (in_range(t.y, ray)) {
        root = t.y;
    } else {
        return rayhit;
    }

    // // Calculate the determinant of quadratic formula
    // vec3 oc = ray.origin - sphere.center;
    // float a = dot(ray.direction, ray.direction);
    // float half_b = dot(oc, ray.direction);
    // float c = dot(oc, oc) - (sphere.radius * sphere.radius);

    // float discriminant = half_b * half_b - a*c;

    // // Early return if ray does not hit
    // if (discriminant < 0.0) {
    //     return rayhit;
    // }

    // float sqrtd = sqrt(discriminant);
    // float root = (-half_b - sqrtd);

    // // If root is within a valid t range and less than previous rayhit
    // if (!in_range(root, ray)) {
    //     root = (-half_b + sqrtd);
    //     if (!in_range(root, ray)) {
    //         return rayhit;
    //     }
    // }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    rayhit.transform_index = current_transform_index;
    ray.end = root;

    return rayhit;
}

RayHit hit_sphere_gems(inout Ray ray, int object_id, inout RayHit rayhit) {

    Sphere sphere = spheres.data[get_object_index(object_id)];

    // Calculate the determinant of quadratic formula
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(-oc, ray.direction);
    float r_sqrd = (sphere.radius * sphere.radius);

    vec3 temp = oc + half_b * ray.direction;
    float discriminant = r_sqrd - dot(temp, temp);

    // Early return if ray does not hit
    if (discriminant < 0.0) {
        return rayhit;
    }

    float c = dot(oc, oc) - r_sqrd;
    float sqrtd = sqrt(discriminant);
    float q = half_b + sign(half_b) * sqrtd;
    float root = c / q;

    // If root is within a valid t range and less than previous rayhit
    if (!in_range(root, ray)) {
        root = q;
        if (!in_range(root, ray)) {
            return rayhit;
        }
    }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    rayhit.transform_index = current_transform_index;
    ray.end = root;

    return rayhit;
}

RayHit hit_spheres(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope sphere array to bypass function parameter limitations
    for (int i = 0; i < spheres.data.length(); ++i) {
        hit_sphere(ray, i + (is_sphere << 24), rayhit);
    }
    return rayhit;
}

RayHit hit_plane(inout Ray ray, int object_id, inout RayHit rayhit) {

    Plane plane = planes.data[get_object_index(object_id)];

    float intersection_t = ((plane.d - dot(ray.origin, plane.normal)) /
                            dot(plane.normal, ray.direction));

    // Early return if plane is paralell, even if the ray is contained in the plane
    if (isnan(intersection_t) || (isinf(intersection_t))) {
        return rayhit;
    }

    // Early return if t is not in range of ray
    if (!in_range(intersection_t, ray)) {
        return rayhit;
    }

    // Set rayhit variables
    rayhit.hit = true;
    rayhit.object_id = object_id;
    rayhit.transform_index = current_transform_index; // Not really relevant to planes
    ray.end = intersection_t;

    return rayhit;
}

// TODO 0: array.length gives the total length of the array including empty values.
// Make integer passthrough to tell how many real values are in the array.
RayHit hit_planes(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope planes array to bypass function parameter limitations
    for (int i = 0; i < planes.data.length(); ++i) {
        hit_plane(ray, i + (is_plane << 24), rayhit);
    }
    return rayhit;
}


// RAY-TRIANGLE INTERSECTION FUNCTIONS
// ===================================

// TODO 2: Compare branched vs branchless when support for importing meshes
bool hit_triangle_MT_branchless(inout Ray ray, int object_id, inout RayHit rayhit) {
    // Implementation of the Moller-Trumbore algorithm made by BrunoLevy, fitted to project
    // https://stackoverflow.com/a/42752998

    int triangle_index = get_object_index(object_id);

    vec3 A = triangles.data[triangle_index].point1;
    vec3 B = triangles.data[triangle_index].point2;
    vec3 C = triangles.data[triangle_index].point3;

    vec3 E1 = B-A;
    vec3 E2 = C-A;
    vec3 N = cross(E1,E2);
    float det = -dot(ray.direction, N);
    float invdet = 1.0 / det;
    vec3 AO  = ray.origin - A;
    vec3 DAO = cross(AO, ray.direction);
    float u =  dot(E2,DAO) * invdet;
    float v = -dot(E1,DAO) * invdet;
    float t =  dot(AO,N)  * invdet;

    // NOTE: CAN BE OPTIMIZED LATER
    if ((det >= 1e-6 && in_range(t, ray) && u >= 0.0 && v >= 0.0 && (u+v) <= 1.0)) {
        rayhit.hit = true;
        rayhit.object_id = object_id;
        rayhit.transform_index = current_transform_index;
        rayhit.uv = vec2(u, v);
        ray.end = t;
        return true;
    }

    return false;
}

bool hit_triangle_MT(inout Ray ray, int object_id, inout RayHit rayhit) {
    // Implementation of the Moller-Trumbore algorithm made by BrunoLevy, fitted to project
    // https://stackoverflow.com/a/42752998

    int triangle_index = get_object_index(object_id);

    vec3 A = triangles.data[triangle_index].point1;
    vec3 B = triangles.data[triangle_index].point2;
    vec3 C = triangles.data[triangle_index].point3;

    vec3 E1 = B-A;
    vec3 E2 = C-A;
    vec3 N = cross(E1,E2);
    float det = -dot(ray.direction, N);
    // TODO 3: Add global backface cull flag and object flag

    // If ray is parallel to triangle plane
    if (near_zero(det)) {
        return false;
    }

    float invdet = 1.0 / det;
    vec3 AO = ray.origin - A;
    float t = dot(AO,N) * invdet;

    if (!in_range(t, ray)) {
        return false;
    }

    vec3 DAO = cross(AO, ray.direction);
    float u = dot(C - A, DAO) * invdet;
    float v = -dot(B - A, DAO) * invdet;

    if (u >= 0.0 && v >= 0.0 && (u+v) <= 1.0) {
        rayhit.hit = true;
        rayhit.object_id = object_id;
        rayhit.transform_index = current_transform_index;
        rayhit.uv = vec2(u, v);
        ray.end = t;
        return true;
    }

    return false;
}

RayHit hit_triangles(inout Ray ray, inout RayHit rayhit) {
    // Uses global scope planes array to bypass function parameter limitations
    for (int i = 0; i < triangles.data.length(); ++i) {
        hit_triangle_MT(ray, i + (is_triangle << 24), rayhit);
    }
    return rayhit;
}

void hit_object(inout Ray ray, inout RayHit rayhit, int object_id) {
    // Chooses the appropriate hit_ function for given object_type
    int object_type = get_object_type(object_id);
    object_hit_count++;

    if (object_type == is_sphere) {
        // Iquilez method, more precise, slower
        // TODO 3: Try to optimize i. quilez method
        // TODO 3: Try to optimize Ray tracing gems method
        // hit_sphere(ray, object_id, rayhit);
        // hit_sphere_iquilez(ray, object_id, rayhit);
        hit_sphere_gems(ray, object_id, rayhit);
    } else if (object_type == is_triangle) {
        // TODO 2: compare with branchless
        hit_triangle_MT(ray, object_id, rayhit);
        // hit_triangle_MT_branchless(ray, object_id, rayhit);
    }
}


// OTHER RAY FUNCTIONS
// ===================

// Resolves intersextion point, normal and other information from rayhit
RayHit determine_rayhit(Ray ray_in, inout RayHit rayhit) {
    int object_type = get_object_type(rayhit.object_id);
    int object_index = get_object_index(rayhit.object_id);

    // TODO 2: texture_id should also be an index to data with the following:
    //  vec3 offset
    //  vec3 scale
    //  bool ignore_albedo

    // Procedure for hitting sphere
    if (object_type == is_sphere) {
        Sphere sphere = spheres.data[object_index];
        rayhit.mtl_index = sphere.mtl_index;
        rayhit.texture_id = sphere.texture_id;

        // ray.direction * t is not used for hit point calculation because it is too imprecise.
        if (rayhit.transform_index >= 0) {
            mat4 m = transforms.data[rayhit.transform_index].matrix;
            mat4 matrix = inverse(m);

            Ray transformed_ray = ray_in;
            transformed_ray.direction = (m * vec4(ray_in.direction, 0)).xyz;
            transformed_ray.origin = (m * vec4(ray_in.origin, 1)).xyz;

            vec3 unit_sphere_normal = normalize((ray_at(transformed_ray) - sphere.center));

            // Setting uvs early gives them the rotation of the sphere.
            rayhit.uv = sphere_get_uv(unit_sphere_normal);
            rayhit.point = sphere.center + unit_sphere_normal * sphere.radius;
            rayhit.point = ((matrix * vec4(rayhit.point , 1)).xyz);
            rayhit.normal = normalize((vec4(unit_sphere_normal , 0) * m).xyz);
        } else {
            rayhit.normal = normalize(ray_at(ray_in) - sphere.center);
            rayhit.uv = sphere_get_uv(rayhit.normal);
            rayhit.point = sphere.center + rayhit.normal * sphere.radius;
        }

    // Procedure for hitting plane
    } else if (object_type == is_plane) {
        Plane plane = planes.data[object_index];
        rayhit.point = ray_at(ray_in);
        rayhit.mtl_index = plane.mtl_index;
        rayhit.texture_id = plane.texture_id;
        rayhit.normal = plane.normal;

    // Procedure for hitting triangle
    } else if (object_type == is_triangle) {
        Triangle triangle = triangles.data[object_index];
        rayhit.mtl_index = triangle.mtl_index;
        rayhit.texture_id = triangle.texture_id;

        // rayhit.normal = triangle.normal;
        rayhit.normal = normalize(cross(triangle.point1 - triangle.point3, triangle.point1 - triangle.point2));

        rayhit.point = (
            rayhit.uv.x * triangle.point2 +
            rayhit.uv.y * triangle.point3 +
            (1 - rayhit.uv.x - rayhit.uv.y) * triangle.point1
        );

        if (rayhit.transform_index >= 0) {
            mat4 m = transforms.data[rayhit.transform_index].matrix;
            mat4 matrix = inverse(m);

            rayhit.normal = normalize((vec4(rayhit.normal, 0) * m).xyz);
            rayhit.point = (matrix * vec4(rayhit.point, 1)).xyz;
        }

        // rayhit.uv is currently given in barycentric coordinates.
        // TODO 2: Convert barycentric coordinates to uv coordinates here.

        // To make concave surface out of transformed sphere, or grids, or brush
        // TODO 2: Make cull mask

        // TODO 2: Flipping normals needs to be determined by a flag.
        // Also move decision out of determine rayhit.
        if (dot(rayhit.normal, ray_in.direction) > 0) {
            rayhit.normal *= -1;
        }
    }

    rayhit.color = vec4(materials.data[rayhit.mtl_index].albedo, 1);
    #if USE_EMISSION
    is_emissive = materials.data[rayhit.mtl_index].is_emissive;
    #endif
    return rayhit;
}

RayHit check_ray_hit(inout Ray ray) {
    RayHit rayhit = empty_rayhit();

    hit_spheres(ray, rayhit);
    hit_triangles(ray, rayhit);
    hit_planes(ray, rayhit);

    return rayhit;
}

// Stack of indices of nodes yet to traverse
// NOTE: might need to be bigger for larger scenes and/or with higher order trees
int to_visit[max_bvh_depth];
int to_visit_i;

int temp_children[order];
float temp_ts[order];

#if use_early_t_break
float to_visit_t[max_bvh_depth];
#endif

void calculate_top_node(inout Ray ray, inout RayHit rayhit, vec3 inv_dir, bvec3 is_neg) {
    int current_index = to_visit[--to_visit_i];

    BVHNode node = BVH.list[current_index];
    int node_id = NODE_node_id;
    int node_index = get_node_index(node_id);
    int node_size = get_node_size(node_id);

    /* All nodes in to_visit should be in sorted order,
        we can break if the last node is out of range
    NOTE: This is slow for first rays, but seem comparable for secondary rays.
    TODO 3: Make toggle to use this for secondary rays
    */
    #if use_early_t_break
    if (!in_range(to_visit_t[to_visit_i], ray)) {
        return;
    }
    #endif

    // If node is leaf node, hit all children
    // node_index pointing to nodes should never be zero (root_node)
    // node_index should always be negative for bit manip consistency
    if (node_index <= 0) {
        for (int k = 0; k < node_size; k++) {
            hit_object(ray, rayhit, object_ids.list[abs(node_index) + k - 1]);
        }
        return;
    }

    int added_children = 0;
    // Do hit check on child inner nodes and add them to temp array
    for (int l = 0; l < node_size; l++) {
        BVHNode child = BVH.list[node_index + l];

        float aabb_t = hit_AABB(ray, child.bbox, inv_dir, is_neg);

        // xin_range much faster, but has an artifact
        if (in_range(aabb_t, ray)) {
            added_children++;
            temp_ts[l] = aabb_t;
            temp_children[l] = node_index + l;
        }
    }

    // TODO 1: COnsider min heap or insertion sort
    // Add nodes to stack in a sorted order
    to_visit_i += added_children;
    for (int i = 0; i < added_children; i++) { // Looping over constant is not faster here
        // Finds smallest t, closest box
        float smallest_t = infinity;
        int smallest_index = order;
        for (int j = 0; j < order; j++) { // Looping over constant is faster here
            if (temp_ts[j] < smallest_t ) {
                smallest_t = temp_ts[j];
                smallest_index = j;
            }
        }

        // Zero out the smallest
        temp_ts[smallest_index] = infinity;
        to_visit[to_visit_i - i - 1] = temp_children[smallest_index];
        #if use_early_t_break
        to_visit_t[to_visit_i - i - 1] = smallest_t;
        #endif
    }
}

float check_ray_hit_BVH_mesh(Ray ray, inout RayHit rayhit) {

    // Pre-compute values for hit detection
    vec3 inv_direction = vec3(1) / ray.direction;
    bvec3 is_dir_negative = bvec3(inv_direction.x < 0., inv_direction.y < 0., inv_direction.z < 0.);

    // Index to current node being processed
    int current_index;
    int start_index = to_visit_i;

    while (to_visit_i >= start_index && to_visit_i <= max_bvh_depth) {
        calculate_top_node(ray, rayhit, inv_direction, is_dir_negative);
    }

    return ray.end;
}

RayHit check_ray_hit_BVH(inout Ray ray) {
    RayHit rayhit = empty_rayhit();

    // NOTE: Objects that go before bvh can be used as Occluders
    hit_planes(ray, rayhit);

    // Pre-compute values for hit detection
    vec3 inv_direction = vec3(1) / ray.direction;
    bvec3 is_dir_negative = bvec3(inv_direction.x < 0., inv_direction.y < 0., inv_direction.z < 0.);

    // TODO 3: Another improvement might be to precompute all rays for every mesh per trace call

    // Test if root node is hit by ray
    float root_hit = hit_AABB(ray, BVH.list[0].bbox, inv_direction, is_dir_negative);

    // Index to top of the stack, points to vacant spot ABOVE the stack
    to_visit_i = (in_range(root_hit, ray)) ? 1 : 0;
    to_visit[0] = 0;

    #if use_early_t_break
    to_visit_t[0] = root_hit;
    #endif

    for (int h = 0; h < order; h++) {
        temp_ts[h] = infinity;
    }

    //         // hit_object(ray, rayhit, object_ids.list[0]);
    //         // hit_object(ray, rayhit, object_ids.list[1]);


    //     // calculate_top_node(ray, rayhit, inv_direction, is_dir_negative);
    // }
    // return rayhit;


    while (to_visit_i > 0 && to_visit_i <= max_bvh_depth) {
        int current_index = to_visit[--to_visit_i];

        BVHNode node = BVH.list[current_index];
        int node_id = NODE_node_id;
        int node_index = get_node_index(node_id);
        int node_size = get_node_size(node_id);

        /* All nodes in to_visit should be in sorted order,
         we can break if the last node is out of range
        NOTE: This is slow for first rays, but seem comparable for secondary rays.
        TODO 3: Make toggle to use this for secondary rays
        */
        #if use_early_t_break
        if (!in_range(to_visit_t[to_visit_i], ray)) {
            break;
        }
        #endif

        int transform_index = NODE_node_transform;
        if (transform_index >= 0) {

            mat4 matrix = transforms.data[transform_index].matrix;

            // To keep ray direction normalized, we have to change the scaling of start and end
            Ray new_ray = ray;
            vec3 unnormalized = ((matrix * vec4(ray.direction, 0)).xyz);
            float direction_length = length(unnormalized);

            new_ray.direction = unnormalized / direction_length;
            new_ray.origin = (matrix * vec4(ray.origin, 1)).xyz;
            new_ray.end *= direction_length;
            new_ray.start *= direction_length;

            #if use_early_t_break
            BVHNode child = BVH.list[node_index];
            float aabb_t = hit_AABB(ray, child.bbox, inv_direction, is_dir_negative);
            to_visit_t[to_visit_i] = aabb_t;
            #endif
            to_visit[to_visit_i++] = node_index;

            current_transform_index = transform_index;
            ray.end = check_ray_hit_BVH_mesh(new_ray, rayhit) / direction_length;
            current_transform_index = -1;

            continue;
        }

        to_visit_i++;
        calculate_top_node(ray, rayhit, inv_direction, is_dir_negative);
    }

    return rayhit;
}

// RAY-BOUNCE FUNCTIONS
// ====================
Ray scatter_ray(Ray ray_in, vec3 point, vec3 normal, int material) {
    // TODO 2: Change the way rays are created based on roughness, less/ more scatter
    vec3 new_origin = offset_ray(point, normal);

    // Returns a scattered ray based on ray_in and hit information
    vec3 ray_dir = random_point_on_sphere() + normal;

    // If created ray pointed in opposite direction of normal
    ray_dir = near_zero(ray_dir) ? normal : ray_dir;

    // Make sure reflected ray points in the same way as normal
    ray_dir = dot(ray_dir, normal) < 0. ? ray_dir * -1.0 : ray_dir;

    return new_ray(new_origin, ray_dir);
}

Ray reflect_ray(Ray ray_in, vec3 point, vec3 normal, int material) {
    // Returns a new reflected ray based on ray_in and hit information
    vec3 new_origin = offset_ray(point, normal);

    float metallic = materials.data[material].metallic;

    // Metallic vlaues 0.5 look all the same
    // TODO 2: Redo how metallic works
    vec3 reflected_dir = reflect(ray_in.direction, normal) * metallic;
    vec3 dir_offset = random_point_on_sphere() * (1. - metallic);

    vec3 ray_dir = reflected_dir + dir_offset;

    // Reflects ray if it points into the object
    if (dot(ray_dir, normal) < 0.) {
        ray_dir = reflect(ray_dir, normal);
    }

    return new_ray(new_origin, ray_dir);
}

int get_material(int material_index, int highest_priority, bool ignore_self) {
    // Loop over materials that we have entered and not left,
    //  pick the one with the highest dielectric_priority, ignore default values if specified
    int current_index = material_index;
    for (int i = 0; i < max_overlapping_objects; i++) {
        InsideOf index = inside_of[i];
        if (index.dielectric_priority > highest_priority) {
            if (!(material_index == index.material_index) || !ignore_self) {
                highest_priority = index.dielectric_priority;
                current_index = index.material_index;
            } else {
                // same material is true, we ignore the same material one time
                ignore_self = false;
            }
        }
    }

    return current_index;
}

ivec2 get_highest_priority_materials() {
    return ivec2(inside_of[0].material_index, inside_of[1].material_index);
}

// TODO 3: Add render_mode to see if more objects than allowed are overlapping
// Adds new material to be ior tracked in sorted array inside_of
void add_material_to_inside_of(int material_index, int priority) {
    int shift = 1;
    int insert_index = 0;
    for (int i = max_overlapping_objects - 1; i >= 0; i--) {
        InsideOf index = inside_of[i];
        if (priority < index.dielectric_priority && shift == 1) {
            insert_index = i + 1;
            shift = 0;
        }
        inside_of[i] = inside_of[i - shift];
    }
    inside_of[insert_index] = InsideOf(material_index, priority);
    inside_of_count++;
    // if (inside_of_count == 2 && 2 == inside_of[1].material_index) {
    //     debug_black;
    // }
}

void remove_material_from_inside_of(int material_index) {
    int shift = 0;
    // TODO 1: Previous testing was probably flawed bc of out of bounds indexing. Re-test
    // NOTE: inside_of_count tested to be faster than looping over entire array
    // NOTE: Newer testing show that looping over entire array is faster
    for (int i = 0; i < max_overlapping_objects - 1; i++) {
        InsideOf index = inside_of[i];
        if (shift == 0 && material_index == index.material_index) {
            shift = 1;
        }
        inside_of[i] = inside_of[i + shift];
    }
    inside_of[max_overlapping_objects - 1] = empty_inside();
    inside_of_count--;
}


void material_chooser(
        RayHit rayhit,
        bool is_inside,
        inout vec3 out_normal,
        inout int out_material,
        out float out_ior
) {
    // We can assume that the out_normal we get is rayhit.normal
    // and out_material is rayhit.mtl_index
    // is_inside = bool(dot(rayhit.normal, ray_in.direction) > 0.);
    // out_normal = (is_inside) ? -rayhit.normal : rayhit.normal;
    Material material = materials.data[rayhit.mtl_index];

    int object_material = rayhit.mtl_index;
    ivec2 material_indices = get_highest_priority_materials();
    // TODO 2: make warning in godot for whenever manx refraction depth has been reached.
    if (is_inside) {
        if (inside_of_count == 1) {
            // Material outside is air.
            out_ior = IOR_air;
            out_material = -1;
                // if (material_indices.y == 3) {debug_black;}
            // ignore_attenuation = true;
        } else {
            if (material_indices.x != object_material || material_indices.y == object_material) {
                // if (material_indices.y == object_material) {
                    // Material on both sides of object are the same and are the same as object's material.
                    // remove_material_from_inside_of(object_material);
                    // ignore_attenuation = true;

                    // if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

                    out_material = current_material;

                    // return new_ray(new_origin, ray_in.direction);
                // }
            } else {
                // material on inside is material's, material on outside is different.
                // TODO 0: Should do make new ray based on outside's material!
                // ignore_attenuation = true;
                out_ior = materials.data[material_indices.y].IOR;
                out_material = material_indices.y;
                out_normal *= -1;

            }
            // else {
            //     // Material on both sides of object are the same, but not the same as object's material.
            //     remove_material_from_inside_of(object_material);
            //     ignore_attenuation = true;

            //     if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

            //     return new_ray(new_origin, ray_in.direction);
            // }
        }
    } else {
        #define is_same_material material_indices.x == object_material
        #define old_priority_is_higher material.dielectric_priority < inside_of[0].dielectric_priority

        #if use_refraction_tracking==2
        #define ior_priority inside_of_count
        #elif use_refraction_tracking==3
        #define ior_priority material.dielectric_priority
        #endif

        if (is_same_material || old_priority_is_higher) {
            // Material on both sides of object are the same and are the same as object's material.
            // Or
            // The previous material we were inside of has a higher priority than the new material.
            // add_material_to_inside_of(object_material, ior_priority);
            // Moved outside later
            // ignore_attenuation = true;

            // if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

            out_material = current_material;
        } else {
            out_ior = material.IOR;
            out_material = object_material;
            // debug_black;
        }
    }
    // current_material = material_indices.x;
}


Ray refract_ray(
        Ray ray_in,
        inout RayHit rayhit,
        // int in_material_index,
        int material_index,
        float out_ior
) {
    // Returns a refracted or reflected ray based on ray_in and rayhit
    // TODO 3: Add support for cpu to send InsideOf buffer based on camera position
    // TODO 3: Add tiny random direction change coupled with color shift, prism, diffraction
    // TODO 2: Implement Beer's law:
    // https://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_3_Refractions_and_Beers_Law.shtml

    // Whether object is inside the current object
    bool is_inside = bool(dot(rayhit.normal, ray_in.direction) > 0.);
    vec3 normal = (is_inside) ? -rayhit.normal : rayhit.normal;

    vec3 new_origin = offset_ray(rayhit.point, -normal);

    // Material material = materials.data[material_index];
    Material object_material = materials.data[rayhit.mtl_index];

    #if use_refraction_tracking==0
    float eta = (is_inside) ? object_material.IOR / IOR_air : IOR_air / object_material.IOR ;
    if (is_inside) {
        ignore_attenuation = true;
    }

    #elif use_refraction_tracking==1
    float eta_in = current_IOR;
    float eta_out = (is_inside) ? IOR_air : object_material.IOR;
    float eta = eta_in / eta_out;

    #elif use_refraction_tracking==2 || use_refraction_tracking==3

    float eta_in = current_IOR;
    #if USE_NEW_REFRACTION_TRACKING
    float eta_out;
    int object_material_index = rayhit.mtl_index;
    ivec2 material_indices = get_highest_priority_materials();
    // TODO 2: make warning in godot for whenever manx refraction depth has been reached.
    if (is_inside) {
        if (inside_of_count == 1) {
            // Material outside is air.
            eta_out = IOR_air;
                // if (material_indices.y == 3) {debug_black;}
            ignore_attenuation = true;
        } else {
            if (material_indices.x == object_material_index) {
                if (material_indices.y == object_material_index) {
                    // Material on both sides of object are the same and are the same as object's material.
                    remove_material_from_inside_of(object_material_index);
                    ignore_attenuation = true;

                    if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

                    return new_ray(new_origin, ray_in.direction);
                }
            // } else {
                // material on inside is material's, material on outside is different.
                ignore_attenuation = true;
                eta_out = materials.data[material_indices.y].IOR;

            } else {
                // Material on both sides of object are the same, but not the same as object's material.
                remove_material_from_inside_of(object_material_index);
                ignore_attenuation = true;

                if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

                return new_ray(new_origin, ray_in.direction);
            }
        }
    } else {
        #define is_same_material_ material_indices.x == object_material_index
        #define old_priority_is_higher_ object_material.dielectric_priority < inside_of[0].dielectric_priority

        #if use_refraction_tracking==2
        #define ior_priority_ inside_of_count
        #elif use_refraction_tracking==3
        #define ior_priority_ object_material.dielectric_priority
        #endif

        if (is_same_material_ || old_priority_is_higher_) {
            // Material on both sides of object are the same and are the same as object's material.
            // Or
            // The previous material we were inside of has a higher priority than the new material.
            add_material_to_inside_of(object_material_index, ior_priority_);
            ignore_attenuation = true;

            if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

            return new_ray(new_origin, ray_in.direction);

        } else {
            eta_out = object_material.IOR;
        }
    }
    #elif !USE_NEW_REFRACTION_TRACKING
    // If ray is inside object ignore rayhti.mtl_index as having a possible eta_out, else
    //  rayhit.mtl_index is default material if no other materials are in inside_of.
    int dielectric_priority = is_inside ? neg_int_limit : object_material.dielectric_priority;
    int temp_material = get_material(rayhit.mtl_index, dielectric_priority, is_inside);

    float eta_out = materials.data[temp_material].IOR;
    if (is_inside) {
        ignore_attenuation = true;
    }
    #endif
    /*
        ray hits outside of object:
            - ray is in air. New material added to stack, apply attenuation, bend ray.
            - ray comes from shallower material. New material added to stack, apply attenuation, bend ray.
            - ray comes from deeper material. New material added to stack, ignore attenuation, straigth ray.
            - ray comes from same material. New material added to stack, ignore attenuation, straight ray.
        ray hits from inside object:
            if  inside_of_count == 1:
                - use the material of object, out IOR is IOR_air. Remove material, ignore attenuation, bend ray.
            else inside_of_count > 1: Ignore object material to find outside material
                if current_material == object.material.
                    - ray enters same material. remove material, ignore attenuation, straight ray.
                    - ray enters different material. Remove old material, apply attenuation, bend ray.
                else current_matrial.depth < object.material.depth
                    - ray enters same material. remove object material, ignore attenuation, straight ray.
    */

    // float eta_out = out_ior;
    float eta = eta_in / eta_out;

    // If ratio is one the ray will travel in a straight line
    if (is_close(eta, 1.0)) {
        // If ray was inside and went out, remove from inside_of list
        if (is_inside) {
            remove_material_from_inside_of(rayhit.mtl_index);
        } else {
            // If ray was outside and refracted, add to inside_of list
            add_material_to_inside_of(rayhit.mtl_index, object_material.dielectric_priority);
        }

        // TODO! 3: Only invalidate color if this object has the same color as the previous object
        // Handle this in a more explicit way.
        ignore_attenuation = true;

        // Add extra available bounces when ray refracts/goes through another object
        if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

        return new_ray(new_origin, ray_in.direction);
    }
    #endif

    // Calculate whether angle is shallow enough to disallow refraction
    // TODO 0: Convert to macros
    float cos_theta = min(dot(-ray_in.direction, normal), 1.);
    float sin_theta = sqrt(1. - cos_theta * cos_theta);
    bool cannot_refract = eta * sin_theta > 1.;
    // if (cannot_refract) {debug_black;}

    // Check for internal reflection
    if ((reflectance(eta, cos_theta) * (object_material.reflectivity) > noise(random)) || cannot_refract) {
        return new_ray(offset_ray(rayhit.point, normal), reflect(ray_in.direction, normal));
    }

    #if use_refraction_tracking
    current_IOR = eta_out;
    current_material = material_index;
    #endif

    #if use_refraction_tracking==2 || use_refraction_tracking==3
    // If ray was inside and went out, remove from inside_of list
    if (is_inside) {
        remove_material_from_inside_of(rayhit.mtl_index);
    } else {
        // If ray was outside and refracted, add to inside_of list
        add_material_to_inside_of(rayhit.mtl_index, object_material.dielectric_priority);
    }
    #endif

    // Add extra available bounces when ray refracts/goes through another object
    if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}

    return new_ray(new_origin, refract(ray_in.direction, normal, eta));
}

Ray bounce_ray(Ray ray_in, inout RayHit rayhit) {
    // Creates a new ray based material properties from the previous rayhit

    // TODO 0: Optimize to only require one refraction depth test.
    bool is_inside = bool(dot(rayhit.normal, ray_in.direction) > 0.);
    vec3 normal = rayhit.normal;
    int material = rayhit.mtl_index;
    float eta_out = IOR_air;

    #define GO_AWAY 1
    #if GO_AWAY
    material_chooser(rayhit, is_inside, normal, material, eta_out);

    // If we are inside an object, calculate beer's law here

    if (material == -1) {
        // outside material is air
        // Perform this materials refraction
        return refract_ray(ray_in, rayhit, -1, eta_out);
    } else
    if (material == current_material) {
        // Same material do nothjing
        // Same ray, new offset origin
        ignore_attenuation = true;
        if (refraction_bounces < push.max_refraction_bounces - 1) {refraction_bounces++;}
        // debug_black;

        if (is_inside) {
            remove_material_from_inside_of(rayhit.mtl_index);
        } else {
            // If ray was outside and refracted, add to inside_of list
            add_material_to_inside_of(rayhit.mtl_index, materials.data[rayhit.mtl_index].dielectric_priority);
        }

        normal = is_inside ? normal : -normal;
        return new_ray(offset_ray(rayhit.point, normal), ray_in.direction);
    }
    // material = rayhit.mtl_index;
    // eta_out = IOR_air;
    // normal = rayhit.normal;

    rayhit.color = vec4(materials.data[material].albedo, 1);
    #endif

    // Material of a new object.
    // If the object we are in follows Beer's law, finish it.
    // Then perform the ray bounce apropriate for the new material.

    if (materials.data[material].opacity < 1.) {
        return refract_ray(ray_in, rayhit, material, eta_out);
    }

    if (materials.data[material].metallic > 0.) {
        return reflect_ray(ray_in, rayhit.point, normal, material);
    }

    return scatter_ray(ray_in, rayhit.point, normal, material);

}

// MAIN FUNCTIONS
// ==============
vec4 cast_ray(Ray ray) {
    // Casts a ray with bounces and returns the color of the ray

    // Turns out computing colors in the same loop was faster
    // TODO 3: maybe reconsider

    // Calculate rayhits
    Ray new_ray = ray;
    RayHit rayhit;
    refraction_bounces = 0;
    vec4 new_color = vec4(1);
    vec4 tex_col = vec4(1);

    int i = 0;
    if (render_mode_is_single_sample) {
        refraction_bounces = push.max_refraction_bounces;
        i = push.max_default_depth + push.max_refraction_bounces - 1;
    }

    // MICRO-OPT Having the loop be static/const is slightly faster than with having it dynamic
    for (; i < push.max_default_depth + refraction_bounces; i++) {
        if (use_bvh) {
            rayhit = check_ray_hit_BVH(new_ray);
        } else {
            rayhit = check_ray_hit(new_ray);
        }

        // if (rayhit.object_id == previous_object) {
        //     debug_red;
        // }
        // previous_object = rayhit.object_id;

        // Early break if no hit
        if (!rayhit.hit) {
            // Adds sky color as the last rayhit when miss
            rayhit.color = hit_skybox(ray, rayhit);
            new_color *= rayhit.color;
            break;
        }

        determine_rayhit(new_ray, rayhit);

        #if USE_EMISSION
        if (is_emissive) {
            new_color *= rayhit.color;
            break;
        } else {is_emissive = false;} // This never does anything
        #endif

        // Get texture color
        tex_col = get_texture(rayhit);

        new_ray = bounce_ray(new_ray, rayhit);

        // TODO 2: implement attenuation based on incident and exiting angles

        // Rayhit is invalidated if the ray goes through two transparent objects with the same material
        if (!ignore_attenuation) {
            new_color *= rayhit.color * tex_col;
        } else {
            ignore_attenuation = false;
        }
    }

    #if USE_EMISSION
    if (!is_emissive) {
        new_color = vec4(0);
    }
    #endif

    // RENDER MODE COLOR OVERRIDES
    if (show_bvh_view) {
        float a = show_node_count ? float(node_hit_count) / float(push.node_count_threshold) : 0.0;
        float b = show_object_count ? float(object_hit_count) / float(push.object_count_threshold) : 0.0;
        render_mode_color = (max(a, b) > 1.0) ? vec4(1) : vec4(b, 0, a, 0);
    }

    if (show_normal_view) {
        render_mode_color = vec4((rayhit.normal + vec3(1)) / 2.0, 1);
    }

    return new_color;
}


// The code we want to execute in each invocation
void main() {

    // VARIABLE DEFINITIONS
    // ====================

    // Calculate the vectors across the horizontal and down the vertical viewport edges.
    const vec3 viewport_u = push.camera.right * push.camera.viewport_width;
    const vec3 viewport_v = -push.camera.up * push.camera.viewport_height;

    // Calculate the horizontal and vertical delta vectors from pixel to pixel.
    const vec3 pixel_delta_u = viewport_u / push.width;
    const vec3 pixel_delta_v = viewport_v / push.height;

    // Calculate the location of the upper left pixel.
    const vec3 viewport_upper_left = push.camera.pos - push.camera.forward * push.camera.focal_length -
                                     (viewport_u + viewport_v) / 2.;

    const vec3 pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);

    // gl_GlobalInvocationID uniquely identifies this invocation across all work groups
    // const uvec3 UVu = gl_GlobalInvocationID + uvec3(push.image_offset, 0);
    const ivec3 UVi = ivec3(gl_GlobalInvocationID) + ivec3(push.image_offset_x, push.image_offset_y, 0);
    const vec3 UV = vec3(UVi);

    const vec3 pixel_center = pixel00_loc + (UV.x * pixel_delta_u) + (UV.y * pixel_delta_v);

    random.seed = hash(vec3(UV.xy, push.time));

    // Initialize render flags
    parse_flags();

    // CODE
    // ====

    // Create ray with offset
    vec3 offset = (pixel_delta_u / 2) * (rand(float(push.time)) - 1.) +
                  (pixel_delta_v / 2) * (rand(float(push.time)) - 1.);
    vec3 ray_direction = normalize(pixel_center - push.camera.pos + offset);
    Ray ray = new_ray(push.camera.pos, ray_direction);

    // Cast ray
    vec4 new_color = cast_ray(ray);

    // Apply gamma correction
    new_color.rgb = pow(new_color.rgb, vec3(push.camera.gamma));

    // TODO 3: use max_samples to divide
    if (multisample) {
        vec4 prev_col = imageLoad(output_image, UVi.xy);
        new_color = mix(prev_col, new_color, 1.0 / max(1.0, push.frame));
        // new_color = prev_col + new_color / push.max_samples;
        // if (push.frame == 0) {
        //     new_color = vec4(0);
        // }
    }

    // TODO 3: apply gmama to debug colors. At least covnert to sRGB
    if (render_mode_color != vec4(-1)) {
        new_color = render_mode_color;
    }

    if (debug_color != vec4(-1)) {
        new_color = debug_color;
    }

    imageStore(output_image, UVi.xy, new_color);
}
